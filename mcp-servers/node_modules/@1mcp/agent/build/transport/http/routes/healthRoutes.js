import { Router } from 'express';
import rateLimit from 'express-rate-limit';
import logger from '../../../logger/logger.js';
import { HealthService, HealthStatus } from '../../../services/healthService.js';
/**
 * Creates health check routes
 */
export function createHealthRoutes() {
    const router = Router();
    const healthService = HealthService.getInstance();
    // Rate limiter for health endpoints - more permissive than OAuth endpoints
    const createHealthLimiter = () => {
        return rateLimit({
            windowMs: 5 * 60 * 1000, // 5 minutes
            max: 200, // max requests per window per IP (higher limit for monitoring)
            standardHeaders: true,
            legacyHeaders: false,
            message: {
                error: 'Too many health check requests, please try again later.',
                status: 'rate_limited',
            },
        });
    };
    router.use(createHealthLimiter());
    /**
     * Health check endpoint
     * GET /health
     *
     * Returns comprehensive health status including:
     * - Overall system status
     * - MCP server connectivity status
     * - System metrics (uptime, memory)
     * - Configuration status
     */
    const healthHandler = async (req, res) => {
        try {
            logger.debug('Health check requested');
            const healthData = await healthService.performHealthCheck();
            const httpStatusCode = healthService.getHttpStatusCode(healthData.status);
            // Set appropriate headers
            res.setHeader('Content-Type', 'application/json');
            res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
            // Add custom headers for monitoring tools
            res.setHeader('X-Health-Status', healthData.status);
            res.setHeader('X-Service-Version', healthData.version);
            res.setHeader('X-Uptime-Seconds', healthData.system.uptime.toString());
            logger.debug(`Health check completed with status: ${healthData.status}`);
            res.status(httpStatusCode).json(healthData);
        }
        catch (error) {
            logger.error('Health check failed:', error);
            // Return error response with 500 status
            res.status(500).json({
                status: HealthStatus.UNHEALTHY,
                timestamp: new Date().toISOString(),
                error: 'Health check failed',
                message: error instanceof Error ? error.message : 'Unknown error occurred',
            });
        }
    };
    router.get('/', healthHandler);
    /**
     * Simple liveness probe endpoint
     * GET /health/live
     *
     * Returns minimal response for basic liveness checking
     * Always returns 200 if the server is running
     */
    const livenessHandler = (req, res) => {
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Cache-Control', 'no-cache');
        res.status(200).json({
            status: 'alive',
            timestamp: new Date().toISOString(),
        });
    };
    router.get('/live', livenessHandler);
    /**
     * Readiness probe endpoint
     * GET /health/ready
     *
     * Returns 200 if service is ready to accept requests
     * Returns 503 if service is not ready (e.g., configuration not loaded)
     */
    const readinessHandler = async (req, res) => {
        try {
            const healthData = await healthService.performHealthCheck();
            // Service is ready if configuration is loaded
            const isReady = healthData.configuration.loaded;
            const statusCode = isReady ? 200 : 503;
            res.setHeader('Content-Type', 'application/json');
            res.setHeader('Cache-Control', 'no-cache');
            res.status(statusCode).json({
                status: isReady ? 'ready' : 'not_ready',
                timestamp: new Date().toISOString(),
                configuration: healthData.configuration,
            });
        }
        catch (error) {
            logger.error('Readiness check failed:', error);
            res.status(503).json({
                status: 'not_ready',
                timestamp: new Date().toISOString(),
                error: 'Readiness check failed',
            });
        }
    };
    router.get('/ready', readinessHandler);
    return router;
}
// Export the factory function as default
export default createHealthRoutes;
//# sourceMappingURL=healthRoutes.js.map