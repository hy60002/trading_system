import fs from 'fs';
import path from 'path';
import { EventEmitter } from 'events';
import { getGlobalConfigPath, getGlobalConfigDir, DEFAULT_CONFIG } from '../constants.js';
import logger from '../logger/logger.js';
/**
 * Configuration change event types
 */
export var ConfigChangeEvent;
(function (ConfigChangeEvent) {
    ConfigChangeEvent["TRANSPORT_CONFIG_CHANGED"] = "transportConfigChanged";
})(ConfigChangeEvent || (ConfigChangeEvent = {}));
/**
 * MCP configuration manager that handles loading, watching, and reloading MCP server configurations
 */
export class McpConfigManager extends EventEmitter {
    static instance;
    configWatcher = null;
    transportConfig = {};
    configFilePath;
    debounceTimer = null;
    debounceDelayMs = 500; // 500ms debounce delay
    /**
     * Private constructor to enforce singleton pattern
     * @param configFilePath - Optional path to the config file. If not provided, uses global config path
     */
    constructor(configFilePath) {
        super();
        this.configFilePath = configFilePath || getGlobalConfigPath();
        this.ensureConfigExists();
        this.loadConfig();
    }
    /**
     * Get the singleton instance of McpConfigManager
     * @param configFilePath - Optional path to the config file
     */
    static getInstance(configFilePath) {
        if (!McpConfigManager.instance) {
            McpConfigManager.instance = new McpConfigManager(configFilePath);
        }
        return McpConfigManager.instance;
    }
    /**
     * Ensure the config directory and file exist
     */
    ensureConfigExists() {
        try {
            const configDir = getGlobalConfigDir();
            if (!fs.existsSync(configDir)) {
                fs.mkdirSync(configDir, { recursive: true });
                logger.info(`Created config directory: ${configDir}`);
            }
            if (!fs.existsSync(this.configFilePath)) {
                fs.writeFileSync(this.configFilePath, JSON.stringify(DEFAULT_CONFIG, null, 2));
                logger.info(`Created default config file: ${this.configFilePath}`);
            }
        }
        catch (error) {
            logger.error(`Failed to ensure config exists: ${error}`);
            throw error;
        }
    }
    /**
     * Load the configuration from the config file
     */
    loadConfig() {
        try {
            const configData = JSON.parse(fs.readFileSync(this.configFilePath, 'utf8'));
            this.transportConfig = configData.mcpServers || {};
            logger.info('Configuration loaded successfully');
        }
        catch (error) {
            logger.error(`Failed to load configuration: ${error}`);
            this.transportConfig = {};
        }
    }
    /**
     * Start watching the configuration file for changes
     */
    startWatching() {
        if (this.configWatcher) {
            return;
        }
        try {
            this.configWatcher = fs.watch(this.configFilePath, (eventType, filename) => {
                if (filename === path.basename(this.configFilePath) && eventType === 'change') {
                    logger.debug(`Configuration file ${filename} changed, debouncing reload...`);
                    this.debouncedReloadConfig();
                }
            });
            logger.info(`Started watching configuration file: ${this.configFilePath}`);
        }
        catch (error) {
            logger.error(`Failed to start watching configuration file: ${error}`);
        }
    }
    /**
     * Stop watching the configuration file
     */
    stopWatching() {
        if (this.configWatcher) {
            this.configWatcher.close();
            this.configWatcher = null;
            logger.info('Stopped watching configuration file');
        }
        // Clear any pending debounce timer
        if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
            this.debounceTimer = null;
        }
    }
    /**
     * Debounced configuration reload to prevent excessive reloading
     */
    debouncedReloadConfig() {
        // Clear existing timer
        if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
        }
        // Set new timer
        this.debounceTimer = setTimeout(() => {
            logger.info('Debounce period completed, reloading configuration...');
            this.reloadConfig();
            this.debounceTimer = null;
        }, this.debounceDelayMs);
    }
    /**
     * Reload the configuration from the config file
     */
    reloadConfig() {
        const oldConfig = { ...this.transportConfig };
        try {
            this.loadConfig();
            // Emit event for transport configuration changes
            if (JSON.stringify(oldConfig) !== JSON.stringify(this.transportConfig)) {
                logger.info('Transport configuration changed, emitting event');
                this.emit(ConfigChangeEvent.TRANSPORT_CONFIG_CHANGED, this.transportConfig);
            }
        }
        catch (error) {
            logger.error(`Failed to reload configuration: ${error}`);
        }
    }
    /**
     * Get the current transport configuration
     * @returns The current transport configuration
     */
    getTransportConfig() {
        return { ...this.transportConfig };
    }
    /**
     * Get all available tags from the configured servers
     * @returns Array of unique tags from all servers
     */
    getAvailableTags() {
        const tags = new Set();
        for (const [_serverName, serverParams] of Object.entries(this.transportConfig)) {
            // Skip disabled servers
            if (serverParams.disabled) {
                continue;
            }
            // Add tags from server configuration
            if (serverParams.tags && Array.isArray(serverParams.tags)) {
                serverParams.tags.forEach((tag) => tags.add(tag));
            }
        }
        return Array.from(tags).sort();
    }
}
export default McpConfigManager;
//# sourceMappingURL=mcpConfigManager.js.map