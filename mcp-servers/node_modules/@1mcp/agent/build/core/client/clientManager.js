import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { UnauthorizedError } from '@modelcontextprotocol/sdk/client/auth.js';
import logger from '../../logger/logger.js';
import { CONNECTION_RETRY, MCP_SERVER_NAME, MCP_SERVER_VERSION, MCP_CLIENT_CAPABILITIES } from '../../constants.js';
import { ClientConnectionError, ClientNotFoundError, CapabilityError } from '../../utils/errorTypes.js';
import { ClientStatus, } from '../types/index.js';
import { AgentConfigManager } from '../server/agentConfig.js';
import { executeOperation } from '../../utils/operationExecution.js';
export class ClientManager {
    static instance;
    outboundConns = new Map();
    transports = {};
    connectionSemaphore = new Map();
    constructor() { }
    static getOrCreateInstance() {
        if (!ClientManager.instance) {
            ClientManager.instance = new ClientManager();
        }
        return ClientManager.instance;
    }
    static get current() {
        return ClientManager.instance;
    }
    // Test utility method to reset singleton state
    static resetInstance() {
        ClientManager.instance = undefined;
    }
    /**
     * Creates a new MCP client instance
     * @returns A new Client instance
     */
    createClient() {
        return new Client({
            name: MCP_SERVER_NAME,
            version: MCP_SERVER_VERSION,
        }, {
            capabilities: MCP_CLIENT_CAPABILITIES,
        });
    }
    /**
     * Creates a new MCP client instance for external use (e.g., OAuth testing)
     * @returns A new Client instance
     */
    createClientInstance() {
        return this.createClient();
    }
    /**
     * Creates client instances for all transports with retry logic
     * @param transports Record of transport instances
     * @returns Record of client instances
     */
    async createClients(transports) {
        this.transports = transports;
        this.outboundConns.clear();
        for (const [name, transport] of Object.entries(transports)) {
            logger.info(`Creating client for ${name}`);
            try {
                const client = this.createClient();
                // Connect with retry logic
                const connectedClient = await this.connectWithRetry(client, transport, name);
                this.outboundConns.set(name, {
                    name,
                    transport,
                    client: connectedClient,
                    status: ClientStatus.Connected,
                    lastConnected: new Date(),
                });
                logger.info(`Client created for ${name}`);
                connectedClient.onclose = () => {
                    const clientInfo = this.outboundConns.get(name);
                    if (clientInfo) {
                        clientInfo.status = ClientStatus.Disconnected;
                    }
                    logger.info(`Client ${name} disconnected`);
                };
                connectedClient.onerror = (error) => {
                    logger.error(`Client ${name} error: ${error}`);
                };
            }
            catch (error) {
                if (error instanceof OAuthRequiredError) {
                    // Handle OAuth required - set client to AwaitingOAuth status
                    logger.info(`OAuth authorization required for ${name}`);
                    // Try to get authorization URL from OAuth provider
                    let authorizationUrl;
                    try {
                        // Extract OAuth provider from transport if available
                        const oauthProvider = transport.oauthProvider;
                        if (oauthProvider && typeof oauthProvider.getAuthorizationUrl === 'function') {
                            authorizationUrl = oauthProvider.getAuthorizationUrl();
                        }
                    }
                    catch (urlError) {
                        logger.warn(`Could not extract authorization URL for ${name}:`, urlError);
                    }
                    this.outboundConns.set(name, {
                        name,
                        transport,
                        client: error.client,
                        status: ClientStatus.AwaitingOAuth,
                        authorizationUrl,
                        oauthStartTime: new Date(),
                    });
                }
                else {
                    logger.error(`Failed to create client for ${name}: ${error}`);
                    this.outboundConns.set(name, {
                        name,
                        transport,
                        client: this.createClient(),
                        status: ClientStatus.Error,
                        lastError: error instanceof Error ? error : new Error(String(error)),
                    });
                }
            }
        }
        return this.outboundConns;
    }
    /**
     * Connects a client to its transport with retry logic and OAuth support
     * @param client The client to connect
     * @param transport The transport to connect to
     * @param name The name of the client for logging
     * @returns The connected client (may be a new instance after retries)
     */
    async connectWithRetry(client, transport, name) {
        let retryDelay = CONNECTION_RETRY.INITIAL_DELAY_MS;
        let currentClient = client;
        for (let i = 0; i < CONNECTION_RETRY.MAX_ATTEMPTS; i++) {
            try {
                await currentClient.connect(transport);
                const sv = await currentClient.getServerVersion();
                if (sv?.name === MCP_SERVER_NAME) {
                    throw new ClientConnectionError(name, new Error('Aborted to prevent circular dependency'));
                }
                logger.info(`Successfully connected to ${name} with server ${sv?.name} version ${sv?.version}`);
                return currentClient;
            }
            catch (error) {
                // Handle OAuth authorization flow (managed by SDK)
                if (error instanceof UnauthorizedError) {
                    const configManager = AgentConfigManager.getInstance();
                    logger.info(`OAuth authorization required for ${name}. Visit ${configManager.getUrl()}/oauth to authorize`);
                    // Throw special error that includes OAuth info
                    throw new OAuthRequiredError(name, currentClient);
                }
                // Handle other connection errors
                else {
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    logger.error(`Failed to connect to ${name}: ${errorMessage}`);
                    if (i < CONNECTION_RETRY.MAX_ATTEMPTS - 1) {
                        logger.info(`Retrying in ${retryDelay}ms...`);
                        await new Promise((resolve) => setTimeout(resolve, retryDelay));
                        retryDelay *= 2; // Exponential backoff
                        // Create a new client for retry to avoid "already started" errors
                        currentClient = this.createClient();
                    }
                    else {
                        throw new ClientConnectionError(name, error instanceof Error ? error : new Error(String(error)));
                    }
                }
            }
        }
        // This should never be reached due to the throw in the else block above
        throw new ClientConnectionError(name, new Error('Max retries exceeded'));
    }
    /**
     * Gets a client by name with error handling
     * @param clientName The name of the client to get
     * @returns The client instance
     * @throws ClientNotFoundError if the client is not found
     */
    getClient(clientName) {
        const client = this.outboundConns.get(clientName);
        if (!client) {
            throw new ClientNotFoundError(clientName);
        }
        return client;
    }
    /**
     * Gets all outbound connections
     * @returns Map of all outbound connections
     */
    getClients() {
        return this.outboundConns;
    }
    /**
     * Executes a client operation with error handling and retry logic
     * @param clientName The name of the client to use
     * @param operation The operation to execute
     * @param options Operation options including timeout and retry settings
     * @param requiredCapability The capability required for this operation
     */
    async executeClientOperation(clientName, operation, options = {}, requiredCapability) {
        const outboundConn = this.getClient(clientName);
        if (outboundConn.status !== ClientStatus.Connected || !outboundConn.client.transport) {
            throw new ClientConnectionError(clientName, new Error('Client not connected'));
        }
        if (requiredCapability && !outboundConn.capabilities?.[requiredCapability]) {
            throw new CapabilityError(clientName, String(requiredCapability));
        }
        return executeOperation(() => operation(outboundConn), `client ${clientName}`, options);
    }
}
/**
 * Custom error class for OAuth authorization required
 */
export class OAuthRequiredError extends Error {
    serverName;
    client;
    constructor(serverName, client) {
        super(`OAuth authorization required for ${serverName}`);
        this.serverName = serverName;
        this.client = client;
        this.name = 'OAuthRequiredError';
    }
}
//# sourceMappingURL=clientManager.js.map