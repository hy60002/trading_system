import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import logger from '../../logger/logger.js';
import configReloadService from '../../services/configReloadService.js';
import { setupCapabilities } from '../../capabilities/capabilityManager.js';
import { enhanceServerWithLogging } from '../../logger/mcpLoggingEnhancer.js';
import { ServerStatus, } from '../types/index.js';
import { executeOperation } from '../../utils/operationExecution.js';
export class ServerManager {
    static instance;
    inboundConns = new Map();
    serverConfig;
    serverCapabilities;
    outboundConns = new Map();
    transports = {};
    connectionSemaphore = new Map();
    disconnectingIds = new Set();
    constructor(config, capabilities, outboundConns, transports) {
        this.serverConfig = config;
        this.serverCapabilities = capabilities;
        this.outboundConns = outboundConns;
        this.transports = transports;
    }
    static getOrCreateInstance(config, capabilities, outboundConns, transports) {
        if (!ServerManager.instance) {
            ServerManager.instance = new ServerManager(config, capabilities, outboundConns, transports);
        }
        return ServerManager.instance;
    }
    static get current() {
        return ServerManager.instance;
    }
    // Test utility method to reset singleton state
    static resetInstance() {
        if (ServerManager.instance) {
            // Clean up existing connections with forced close
            for (const [sessionId] of ServerManager.instance.inboundConns) {
                ServerManager.instance.disconnectTransport(sessionId, true);
            }
            ServerManager.instance.inboundConns.clear();
            ServerManager.instance.connectionSemaphore.clear();
            ServerManager.instance.disconnectingIds.clear();
        }
        ServerManager.instance = undefined;
    }
    async connectTransport(transport, sessionId, opts) {
        // Check if a connection is already in progress for this session
        const existingConnection = this.connectionSemaphore.get(sessionId);
        if (existingConnection) {
            logger.warn(`Connection already in progress for session ${sessionId}, waiting...`);
            await existingConnection;
            return;
        }
        // Check if transport is already connected
        if (this.inboundConns.has(sessionId)) {
            logger.warn(`Transport already connected for session ${sessionId}`);
            return;
        }
        // Create connection promise to prevent race conditions
        const connectionPromise = this.performConnection(transport, sessionId, opts);
        this.connectionSemaphore.set(sessionId, connectionPromise);
        try {
            await connectionPromise;
        }
        finally {
            // Clean up the semaphore entry
            this.connectionSemaphore.delete(sessionId);
        }
    }
    async performConnection(transport, sessionId, opts) {
        // Set connection timeout
        const connectionTimeoutMs = 30000; // 30 seconds
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error(`Connection timeout for session ${sessionId}`)), connectionTimeoutMs);
        });
        try {
            await Promise.race([this.doConnect(transport, sessionId, opts), timeoutPromise]);
        }
        catch (error) {
            // Update status to Error if connection exists
            const connection = this.inboundConns.get(sessionId);
            if (connection) {
                connection.status = ServerStatus.Error;
                connection.lastError = error instanceof Error ? error : new Error(String(error));
            }
            logger.error(`Failed to connect transport for session ${sessionId}:`, error);
            throw error;
        }
    }
    async doConnect(transport, sessionId, opts) {
        // Create a new server instance for this transport
        const server = new Server(this.serverConfig, this.serverCapabilities);
        // Create server info object first
        const serverInfo = {
            server,
            status: ServerStatus.Connecting,
            connectedAt: new Date(),
            ...opts,
        };
        // Enhance server with logging middleware
        enhanceServerWithLogging(server);
        // Set up capabilities for this server instance
        await setupCapabilities(this.outboundConns, serverInfo);
        // Update the configuration reload service with server info
        configReloadService.updateServerInfo(sessionId, serverInfo);
        // Store the server instance
        this.inboundConns.set(sessionId, serverInfo);
        // Connect the transport to the new server instance
        await server.connect(transport);
        // Update status to Connected after successful connection
        serverInfo.status = ServerStatus.Connected;
        serverInfo.lastConnected = new Date();
        logger.info(`Connected transport for session ${sessionId}`);
    }
    disconnectTransport(sessionId, forceClose = false) {
        // Prevent recursive disconnection calls
        if (this.disconnectingIds.has(sessionId)) {
            return;
        }
        const server = this.inboundConns.get(sessionId);
        if (server) {
            this.disconnectingIds.add(sessionId);
            try {
                // Update status to Disconnected
                server.status = ServerStatus.Disconnected;
                // Only close the transport if explicitly requested (e.g., during shutdown)
                // Don't close if this is called from an onclose handler to avoid recursion
                if (forceClose && server.server.transport) {
                    try {
                        server.server.transport.close();
                    }
                    catch (error) {
                        logger.error(`Error closing transport for session ${sessionId}:`, error);
                    }
                }
                this.inboundConns.delete(sessionId);
                configReloadService.removeServerInfo(sessionId);
                logger.info(`Disconnected transport for session ${sessionId}`);
            }
            finally {
                this.disconnectingIds.delete(sessionId);
            }
        }
    }
    getTransport(sessionId) {
        return this.inboundConns.get(sessionId)?.server.transport;
    }
    getTransports() {
        const transports = new Map();
        for (const [id, server] of this.inboundConns.entries()) {
            if (server.server.transport) {
                transports.set(id, server.server.transport);
            }
        }
        return transports;
    }
    getClientTransports() {
        return this.transports;
    }
    getClients() {
        return this.outboundConns;
    }
    /**
     * Safely get a client by name. Returns undefined if not found or not an own property.
     * Encapsulates access to prevent prototype pollution and accidental key collisions.
     */
    getClient(serverName) {
        return this.outboundConns.get(serverName);
    }
    getActiveTransportsCount() {
        return this.inboundConns.size;
    }
    getServer(sessionId) {
        return this.inboundConns.get(sessionId);
    }
    updateClientsAndTransports(newClients, newTransports) {
        this.outboundConns = newClients;
        this.transports = newTransports;
    }
    /**
     * Executes a server operation with error handling and retry logic
     * @param inboundConn The inbound connection to execute the operation on
     * @param operation The operation to execute
     * @param options Operation options including timeout and retry settings
     */
    async executeServerOperation(inboundConn, operation, options = {}) {
        // Check connection status before executing operation
        if (inboundConn.status !== ServerStatus.Connected || !inboundConn.server.transport) {
            throw new Error(`Cannot execute operation: server status is ${inboundConn.status}`);
        }
        return executeOperation(() => operation(inboundConn), 'server', options);
    }
}
//# sourceMappingURL=serverManager.js.map