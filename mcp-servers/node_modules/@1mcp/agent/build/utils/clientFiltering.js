import logger from '../logger/logger.js';
/**
 * Filters clients by tags
 * @param clients Record of client instances
 * @param tags Array of tags to filter by
 * @returns Filtered record of client instances
 */
export function filterClientsByTags(clients, tags) {
    if (!tags || tags.length === 0) {
        return clients;
    }
    const filteredClients = new Map();
    let matchedClients = 0;
    for (const [name, clientInfo] of clients.entries()) {
        const clientTags = clientInfo.transport.tags || [];
        const hasMatchingTags = clientTags.some((clientTag) => tags.includes(clientTag));
        if (hasMatchingTags) {
            filteredClients.set(name, clientInfo);
            matchedClients++;
        }
    }
    if (matchedClients === 0) {
        logger.warn(`No clients found matching tags: ${tags.join(', ')}`);
    }
    else {
        logger.debug(`Found ${matchedClients} clients matching tags: ${tags.join(', ')}`);
    }
    return filteredClients;
}
/**
 * Filters clients by capabilities
 * @param clients Record of client instances
 * @param capabilities Object containing capabilities to filter by
 * @returns Filtered record of client instances
 */
export function filterClientsByCapabilities(clients, capabilities) {
    const filteredClients = new Map();
    let matchedClients = 0;
    for (const [name, clientInfo] of clients.entries()) {
        const clientCapabilities = clientInfo.capabilities || {};
        const hasMatchingCapabilities = Object.keys(capabilities).every((capability) => {
            const clientCapability = clientCapabilities[capability];
            return clientCapability !== undefined;
        });
        if (hasMatchingCapabilities) {
            filteredClients.set(name, clientInfo);
            matchedClients++;
        }
    }
    if (matchedClients === 0) {
        logger.warn(`No clients found matching capabilities: ${JSON.stringify(capabilities)}`);
    }
    else {
        logger.debug(`Found ${matchedClients} clients matching capabilities: ${JSON.stringify(capabilities)}`);
    }
    return filteredClients;
}
/**
 * Filters clients by multiple criteria
 * @param filters Array of client filters
 * @returns Filtered record of client instances
 */
export function filterClients(...filters) {
    return (clients) => {
        logger.debug(`filterClients: Starting with ${clients.size} clients`, {
            clientNames: Array.from(clients.keys()),
            filterCount: filters.length,
        });
        const result = filters.reduce((filteredClients, filter, index) => {
            const beforeCount = filteredClients.size;
            const afterFiltering = filter(filteredClients);
            const afterCount = afterFiltering.size;
            logger.debug(`filterClients: Filter ${index} reduced clients from ${beforeCount} to ${afterCount}`, {
                beforeNames: Array.from(filteredClients.keys()),
                afterNames: Array.from(afterFiltering.keys()),
            });
            return afterFiltering;
        }, clients);
        logger.debug(`filterClients: Final result has ${result.size} clients`, {
            finalNames: Array.from(result.keys()),
        });
        return result;
    };
}
/**
 * Filters clients by capabilities
 * @param requiredCapabilities Object containing capabilities to filter by
 * @returns Filtered record of client instances
 */
export function byCapabilities(requiredCapabilities) {
    return (clients) => {
        const requiredCaps = Object.keys(requiredCapabilities);
        logger.debug(`byCapabilities: Filtering for capabilities: ${requiredCaps.join(', ')}`);
        return Array.from(clients.entries()).reduce((filtered, [name, clientInfo]) => {
            const clientCaps = clientInfo.capabilities ? Object.keys(clientInfo.capabilities) : [];
            const hasCapabilities = requiredCaps.every((cap) => clientInfo.capabilities && cap in clientInfo.capabilities);
            logger.debug(`byCapabilities: Client ${name}`, {
                clientCapabilities: clientCaps,
                requiredCapabilities: requiredCaps,
                hasCapabilities,
                clientCapabilitiesObject: clientInfo.capabilities,
            });
            if (hasCapabilities) {
                filtered.set(name, clientInfo);
            }
            return filtered;
        }, new Map());
    };
}
/**
 * Filters clients by tags
 * @param tags Array of tags to filter by
 * @returns Filtered record of client instances
 */
export function byTags(tags) {
    return (clients) => {
        logger.debug(`byTags: Filtering for tags: ${tags ? tags.join(', ') : 'none'}`);
        if (!tags || tags.length === 0) {
            logger.debug('byTags: No tags specified, returning all clients');
            return clients;
        }
        return Array.from(clients.entries()).reduce((filtered, [name, clientInfo]) => {
            const clientTags = clientInfo.transport.tags || [];
            const hasMatchingTags = clientTags.some((clientTag) => tags.includes(clientTag));
            logger.debug(`byTags: Client ${name}`, {
                clientTags,
                requiredTags: tags,
                hasMatchingTags,
            });
            if (hasMatchingTags) {
                filtered.set(name, clientInfo);
            }
            return filtered;
        }, new Map());
    };
}
//# sourceMappingURL=clientFiltering.js.map