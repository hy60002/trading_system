import { v4 as uuidv4 } from 'uuid';
import logger from './logger.js';
const activeRequests = new Map();
/**
 * Logs MCP request details
 */
function logRequest(requestId, method, params) {
    logger.info('MCP Request', {
        requestId,
        method,
        params: JSON.stringify(params),
        timestamp: new Date().toISOString(),
    });
}
/**
 * Logs MCP response details
 */
function logResponse(requestId, result, duration) {
    logger.info('MCP Response', {
        requestId,
        duration,
        timestamp: new Date().toISOString(),
    });
}
/**
 * Logs MCP error details
 */
function logError(requestId, error, duration) {
    logger.error('MCP Error', {
        requestId,
        error: error instanceof Error ? error.message : JSON.stringify(error),
        stack: error instanceof Error ? error.stack : undefined,
        duration,
        timestamp: new Date().toISOString(),
    });
}
/**
 * Logs MCP notification details
 */
function logNotification(method, params) {
    logger.info('MCP Notification', {
        method,
        params: JSON.stringify(params),
        timestamp: new Date().toISOString(),
    });
}
/**
 * Wraps the original request handler with logging
 */
function wrapRequestHandler(originalHandler, method) {
    return async (request, extra) => {
        const requestId = uuidv4();
        const startTime = Date.now();
        // Store request context
        activeRequests.set(requestId, {
            requestId,
            method,
            startTime,
        });
        // Log request
        logRequest(requestId, method, request.params);
        try {
            // Execute original handler with the original extra object
            const result = await originalHandler(request, {
                ...extra,
                sendNotification: async (notification) => {
                    logger.info('Sending notification', { requestId, notification });
                    return extra.sendNotification(notification);
                },
                sendRequest: async (request, resultSchema, options) => {
                    logger.info('Sending request', { requestId, request });
                    return extra.sendRequest(request, resultSchema, options);
                },
            });
            // Log response
            const duration = Date.now() - startTime;
            logResponse(requestId, result, duration);
            return result;
        }
        catch (error) {
            // Log error
            const duration = Date.now() - startTime;
            logError(requestId, error, duration);
            throw error;
        }
        finally {
            // Clean up request context
            activeRequests.delete(requestId);
        }
    };
}
/**
 * Wraps the original notification handler with logging
 */
function wrapNotificationHandler(originalHandler, method) {
    return async (notification) => {
        // Log notification
        logNotification(method, notification.params);
        // Execute original handler
        await originalHandler(notification);
    };
}
/**
 * Enhances an MCP server with request/response logging
 */
export function enhanceServerWithLogging(server) {
    // Store original methods
    const originalSetRequestHandler = server.setRequestHandler.bind(server);
    const originalSetNotificationHandler = server.setNotificationHandler.bind(server);
    const originalNotification = server.notification.bind(server);
    // Override request handler registration
    server.setRequestHandler = (schema, handler) => {
        return originalSetRequestHandler(schema, wrapRequestHandler(handler, schema._def.shape().method._def.value));
    };
    // Override notification handler registration
    server.setNotificationHandler = (schema, handler) => {
        return originalSetNotificationHandler(schema, wrapNotificationHandler(handler, schema._def.shape().method._def.value));
    };
    // Override notification sending
    server.notification = (notification) => {
        logNotification(notification.method, notification.params);
        if (!server.transport) {
            logger.warn('Attempted to send notification on disconnected transport');
            return Promise.resolve();
        }
        // Try to send notification, catch connection errors gracefully
        try {
            const result = originalNotification(notification);
            // Handle both sync and async cases
            if (result && typeof result.catch === 'function') {
                // It's a promise - handle async errors
                return result.catch((error) => {
                    if (error instanceof Error && error.message.includes('Not connected')) {
                        logger.warn('Attempted to send notification on disconnected transport');
                        return Promise.resolve();
                    }
                    throw error;
                });
            }
            // Sync result
            return result;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('Not connected')) {
                logger.warn('Attempted to send notification on disconnected transport');
                return Promise.resolve();
            }
            throw error;
        }
    };
}
//# sourceMappingURL=mcpLoggingEnhancer.js.map