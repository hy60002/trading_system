"""
Notification Manager
Multi-channel notification system with rate limiting
"""

import asyncio
import hashlib
import logging
import queue
import time
import aiohttp
from collections import deque
from datetime import datetime
from typing import Dict

# Import handling for both direct and package imports
try:
    from ..config.config import TradingConfig
    from ..utils.telegram_safe_formatter import telegram_formatter
except ImportError:
    import sys
    import os
    sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from config.config import TradingConfig
    from utils.telegram_safe_formatter import telegram_formatter


class NotificationManager:
    """Multi-channel notification system with rate limiting"""
    
    def __init__(self, config: TradingConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Message queue to prevent spam
        self.message_queue = deque(maxlen=100)
        self.last_message_time = {}
        self.min_interval = 60  # Minimum seconds between similar messages
        
        # Priority queues
        self.emergency_queue = queue.PriorityQueue()
        self.normal_queue = queue.Queue()
        
        # Start message processor
        self.processor_task = None
        self.is_running = True
        
        # üîç NOTIFICATION VERIFICATION SYSTEM
        self.verification_stats = {
            'total_notifications_sent': 0,
            'successful_deliveries': 0,
            'failed_deliveries': 0,
            'notification_types': {
                'trade': {'sent': 0, 'success': 0, 'failed': 0},
                'error': {'sent': 0, 'success': 0, 'failed': 0},
                'risk_alert': {'sent': 0, 'success': 0, 'failed': 0},
                'daily_report': {'sent': 0, 'success': 0, 'failed': 0},
                'system': {'sent': 0, 'success': 0, 'failed': 0}
            },
            'telegram_api_errors': [],
            'last_successful_delivery': None,
            'longest_failure_streak': 0,
            'current_failure_streak': 0
        }
        self.notification_verification_task = None
    
    async def initialize(self):
        """Initialize notification system"""
        self.processor_task = asyncio.create_task(self._message_processor())
        
        # Start notification verification system
        self.notification_verification_task = asyncio.create_task(self._notification_verification_loop())
        
        self.logger.info("üîç ÏïåÎ¶º ÏãúÏä§ÌÖú Î∞è Í≤ÄÏ¶ù ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    async def _message_processor(self):
        """Process messages from queues"""
        while self.is_running:
            try:
                # Check emergency queue first
                if not self.emergency_queue.empty():
                    _, _, message = self.emergency_queue.get_nowait()
                    await self._send_message(message)
                
                # Then normal queue
                elif not self.normal_queue.empty():
                    message = self.normal_queue.get_nowait()
                    await self._send_message(message)
                
                await asyncio.sleep(0.1)
                
            except Exception as e:
                self.logger.error(f"Î©îÏãúÏßÄ ÌîÑÎ°úÏÑ∏ÏÑú Ïò§Î•ò: {e}")
                await asyncio.sleep(1)
    
    async def send_notification(self, message: str, priority: str = 'normal', 
                              channel: str = 'telegram', metadata: Dict = None):
        """Send notification with priority and channel selection"""
        # Trade notifications bypass spam protection
        is_trade_notification = metadata and metadata.get('type') == 'trade'
        
        # Check for spam (except for trade notifications)
        message_hash = hashlib.md5(message.encode()).hexdigest()[:8]
        current_time = time.time()
        
        if priority != 'emergency' and not is_trade_notification:
            if message_hash in self.last_message_time:
                if current_time - self.last_message_time[message_hash] < self.min_interval:
                    self.logger.info(f"üìµ Ï§ëÎ≥µ Î©îÏãúÏßÄ Ï∞®Îã®: {message_hash}")
                    return False  # Skip duplicate message
        
        self.last_message_time[message_hash] = current_time
        
        # Create message object with enhanced metadata
        msg_obj = {
            'content': message,
            'channel': channel,
            'timestamp': current_time,
            'priority': priority,
            'metadata': metadata or {},
            'retry_count': 0,
            'max_retries': 3 if is_trade_notification else 1  # More retries for trade notifications
        }
        
        # Queue based on priority with unique ID to prevent comparison issues
        unique_id = time.time()
        
        if priority == 'emergency':
            self.emergency_queue.put((0, unique_id, msg_obj))  # Highest priority
        elif priority == 'high' or is_trade_notification:
            self.emergency_queue.put((1, unique_id, msg_obj))
        else:
            self.normal_queue.put(msg_obj)
        
        return True
    
    async def _send_message(self, msg_obj: Dict):
        """Send message to appropriate channel with retry logic"""
        channel = msg_obj['channel']
        message = msg_obj['content']
        max_retries = msg_obj.get('max_retries', 1)
        
        success = False
        if channel == 'telegram':
            success = await self._send_telegram_message(message, max_retries)
        # Add other channels here (Discord, Email, etc.)
        
        # üîç VERIFICATION: Track notification statistics
        await self._track_notification_delivery(msg_obj, success)
        
        # Log delivery status
        if success:
            self.logger.info(f"‚úÖ Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏÑ±Í≥µ: {channel}")
        else:
            self.logger.error(f"‚ùå Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®: {channel} - {message[:50]}...")
            
            # For critical trade notifications, try additional fallback
            if msg_obj.get('metadata', {}).get('type') == 'trade':
                await self._handle_critical_message_failure(msg_obj)
        
        return success
    
    async def _send_telegram_message(self, message: str, max_retries: int = 3):
        """Send Telegram message with comprehensive retry logic"""
        if not self.config.TELEGRAM_BOT_TOKEN or not self.config.TELEGRAM_CHAT_ID:
            self.logger.warning("ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ï ÎàÑÎùΩ - Î©îÏãúÏßÄ Ï†ÑÏÜ° Í±¥ÎÑàÎúÄ")
            return False
        
        url = f"https://api.telegram.org/bot{self.config.TELEGRAM_BOT_TOKEN}/sendMessage"
        
        # Use JSON with safe HTML formatting to prevent parsing errors
        safe_message = telegram_formatter.escape_html(message)
        payload = {
            "chat_id": self.config.TELEGRAM_CHAT_ID,
            "text": safe_message,
            "disable_web_page_preview": True,
            "parse_mode": "HTML"  # HTML is more stable than Markdown
        }
        
        headers = {
            'Content-Type': 'application/json; charset=utf-8',
            'User-Agent': 'Bitget-Trading-Bot/1.0'
        }
        
        for attempt in range(max_retries + 1):
            try:
                timeout = aiohttp.ClientTimeout(total=30)  # 30 second timeout
                async with aiohttp.ClientSession(timeout=timeout) as session:
                    async with session.post(url, json=payload, headers=headers) as response:
                        if response.status == 200:
                            self.logger.info(f"‚úÖ ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏÑ±Í≥µ (ÏãúÎèÑ {attempt + 1}/{max_retries + 1})")
                            return True
                        
                        elif response.status == 429:  # Rate limited
                            retry_after = int(response.headers.get('Retry-After', 60))
                            self.logger.warning(f"‚è∏Ô∏è ÌÖîÎ†àÍ∑∏Îû® ÏÜçÎèÑ Ï†úÌïú - {retry_after}Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ")
                            await asyncio.sleep(retry_after)
                            continue
                        
                        elif response.status in [400, 401, 403]:  # Client errors - don't retry
                            error_text = await response.text()
                            self.logger.error(f"‚ùå ÌÖîÎ†àÍ∑∏Îû® ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïò§Î•ò (Ïû¨ÏãúÎèÑ ÏïàÌï®): {response.status} - {error_text}")
                            return False
                        
                        else:  # Server errors - retry
                            error_text = await response.text()
                            self.logger.warning(f"‚ö†Ô∏è ÌÖîÎ†àÍ∑∏Îû® ÏÑúÎ≤Ñ Ïò§Î•ò (ÏãúÎèÑ {attempt + 1}/{max_retries + 1}): {response.status} - {error_text}")
                            
                            if attempt < max_retries:
                                wait_time = (2 ** attempt) + 1  # Exponential backoff: 2, 3, 5 seconds
                                await asyncio.sleep(wait_time)
                                continue
                            
            except asyncio.TimeoutError:
                self.logger.warning(f"‚è∞ ÌÖîÎ†àÍ∑∏Îû® ÌÉÄÏûÑÏïÑÏõÉ (ÏãúÎèÑ {attempt + 1}/{max_retries + 1})")
                if attempt < max_retries:
                    await asyncio.sleep(2 ** attempt)  # Exponential backoff
                    continue
                    
            except aiohttp.ClientError as e:
                self.logger.warning(f"üåê ÌÖîÎ†àÍ∑∏Îû® ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò (ÏãúÎèÑ {attempt + 1}/{max_retries + 1}): {e}")
                if attempt < max_retries:
                    await asyncio.sleep(2 ** attempt)  # Exponential backoff
                    continue
                    
            except Exception as e:
                self.logger.error(f"‚ùå ÌÖîÎ†àÍ∑∏Îû® ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•ò (ÏãúÎèÑ {attempt + 1}/{max_retries + 1}): {e}")
                if attempt < max_retries:
                    await asyncio.sleep(2 ** attempt)
                    continue
        
        # All retries failed
        self.logger.error(f"üö® ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏôÑÏ†Ñ Ïã§Ìå® - {max_retries + 1}Ìöå ÏãúÎèÑ ÌõÑ Ìè¨Í∏∞")
        
        # Log failed message for manual review
        self.logger.critical(f"üìù Ïã§Ìå®Ìïú Î©îÏãúÏßÄ ÎÇ¥Ïö©:\n{message}")
        
        return False
    
    async def send_trade_notification(self, symbol: str, action: str, details: Dict):
        """Send formatted trade notification with guaranteed delivery - TelegramSafeFormatter Ï†ÅÏö©"""
        # ÏïàÏ†ÑÌïú Í±∞Îûò ÏïåÎ¶º Î©îÏãúÏßÄ ÏÉùÏÑ±
        message = telegram_formatter.create_safe_trading_alert(
            symbol=symbol,
            action=action, 
            price=details.get('price', 0),
            confidence=details.get('confidence', 50),
            reason=details.get('reason', '')
        )
        
        # Ï∂îÍ∞Ä ÏÑ∏Î∂ÄÏ†ïÎ≥¥Îäî ÏïàÏ†ÑÌïòÍ≤å Ï∂îÍ∞Ä
        if 'leverage' in details:
            safe_leverage = telegram_formatter.escape_html(str(details['leverage']))
            message += f"\n‚ö° <b>Î†àÎ≤ÑÎ¶¨ÏßÄ</b>: {safe_leverage}x"
        
        if 'pnl' in details:
            pnl = details['pnl']
            pnl_emoji = 'üí∞' if pnl > 0 else 'üîª'
            message += f"\n{pnl_emoji} <b>ÏÜêÏùµ</b>: {pnl:+.2f}%"
        
        if 'current_balance' in details:
            message += f"\nüí≥ <b>ÌòÑÏû¨ ÏûîÍ≥†</b>: ${details['current_balance']:,.2f}"
        
        # Determine priority - trade notifications are always high priority
        priority = 'high'
        if action in ['open_long', 'open_short']:
            priority = 'high'  # New positions are high priority
        if 'emergency' in details.get('reason', '').lower():
            priority = 'emergency'
        
        # Enhanced logging for trade notifications
        self.logger.info(f"üì§ Í±∞Îûò ÏïåÎ¶º Î∞úÏÜ° ÏãúÏûë: {symbol} {action} at ${details.get('price', 0):,.2f}")
        
        success = await self.send_notification(message, priority=priority, metadata={
            'type': 'trade',
            'symbol': symbol,
            'action': action,
            'price': details.get('price'),
            'quantity': details.get('quantity')
        })
        
        if success:
            self.logger.info(f"‚úÖ Í±∞Îûò ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å: {symbol} {action}")
        else:
            self.logger.error(f"‚ùå Í±∞Îûò ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {symbol} {action}")
        
        return success
    
    async def send_daily_report(self, report: str):
        """Send daily performance report - TelegramSafeFormatter Ï†ÅÏö©"""
        # ÏïàÏ†ÑÌïú Î≥¥Í≥†ÏÑú Î©îÏãúÏßÄ Ìè¨Îß∑ÌåÖ
        safe_report = telegram_formatter.escape_html(report)
        header = "üìä <b>ÏùºÏùº Í±∞Îûò ÏÑ±Í≥º Î≥¥Í≥†ÏÑú</b>\n" + "="*30 + "\n\n"
        full_report = header + safe_report
        
        await self.send_notification(full_report, priority='normal')
    
    async def send_error_notification(self, error: str, details: str = "", component: str = ""):
        """Send error notification - TelegramSafeFormatter Ï†ÅÏö©"""
        # ÏïàÏ†ÑÌïú Ïò§Î•ò Î©îÏãúÏßÄ ÏÉùÏÑ±  
        message = telegram_formatter.create_safe_error_message(
            component=component or 'Ïïå Ïàò ÏóÜÏùå',
            error_msg=f"{error}{f' - {details}' if details else ''}",
            severity='ERROR'
        )
        
        await self.send_notification(message, priority='high')
    
    async def send_risk_alert(self, alert_type: str, details: Dict):
        """Send risk management alert"""
        emoji_map = {
            'daily_loss_limit': 'üõë',
            'position_limit': '‚ö†Ô∏è', 
            'drawdown_warning': 'üìâ',
            'correlation_risk': 'üîó',
            'risk_limit_exceeded': 'üö®'
        }
        
        alert_translations = {
            'daily_loss_limit': 'ÏùºÏùº ÏÜêÏã§ ÌïúÍ≥Ñ',
            'position_limit': 'Ìè¨ÏßÄÏÖò ÌïúÍ≥Ñ',
            'drawdown_warning': 'ÎÇôÌè≠ Í≤ΩÍ≥†',
            'correlation_risk': 'ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ ÏúÑÌóò',
            'risk_limit_exceeded': 'Î¶¨Ïä§ÌÅ¨ ÌïúÍ≥Ñ Ï¥àÍ≥º'
        }
        
        emoji = emoji_map.get(alert_type, '‚ö†Ô∏è')
        alert_text = alert_translations.get(alert_type, alert_type.replace('_', ' ').title())
        
        message = f"""
{emoji} **ÏúÑÌóò ÏïåÎ¶º: {alert_text}**

{details.get('message', '')}

ÌòÑÏû¨ ÏÉÅÌÉú:
- ÏùºÏùº ÏÜêÏùµ: {details.get('daily_pnl', 0):+.2f}%
- Î≥¥Ïú† Ìè¨ÏßÄÏÖò: {details.get('open_positions', 0)}Í∞ú
- ÏúÑÌóò ÏàòÏ§Ä: {details.get('risk_level', 'Ïïå Ïàò ÏóÜÏùå')}
"""
        
        await self.send_notification(message, priority='high')
    
    async def _handle_critical_message_failure(self, msg_obj: Dict):
        """Handle critical message delivery failure"""
        self.logger.critical(f"üö® Ï§ëÏöîÌïú Í±∞Îûò ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå® - Î°úÍ∑∏Ïóê Í∏∞Î°ù")
        
        # Log to file for manual review
        trade_data = msg_obj.get('metadata', {})
        failure_log = {
            'timestamp': datetime.now().isoformat(),
            'message': msg_obj['content'],
            'trade_data': trade_data,
            'failure_reason': 'telegram_delivery_failed'
        }
        
        # In a real implementation, you might save this to a special failure log file
        # or send to an alternative notification channel
        self.logger.critical(f"Í±∞Îûò ÏïåÎ¶º Ïã§Ìå® Í∏∞Î°ù: {failure_log}")
    
    async def test_notification_system(self):
        """Test notification system connectivity"""
        test_message = f"üß™ **ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏**\n\nÌÖîÎ†àÍ∑∏Îû® Ïó∞Í≤∞ ÌÖåÏä§Ìä∏\nÏãúÍ∞Ñ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        self.logger.info("üß™ ÏïåÎ¶º ÏãúÏä§ÌÖú Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ ÏãúÏûë...")
        success = await self._send_telegram_message(test_message, max_retries=1)
        
        if success:
            self.logger.info("‚úÖ ÏïåÎ¶º ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ")
        else:
            self.logger.error("‚ùå ÏïåÎ¶º ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏ Ïã§Ìå®")
        
        return success
    
    async def get_system_status(self):
        """Get notification system status"""
        return {
            'is_running': self.is_running,
            'emergency_queue_size': self.emergency_queue.qsize(),
            'normal_queue_size': self.normal_queue.qsize(),
            'telegram_configured': bool(self.config.TELEGRAM_BOT_TOKEN and self.config.TELEGRAM_CHAT_ID),
            'last_message_count': len(self.last_message_time),
            'processor_active': self.processor_task and not self.processor_task.done()
        }
    
    # üîç NOTIFICATION VERIFICATION METHODS
    
    async def _notification_verification_loop(self):
        """ÏïåÎ¶º ÏãúÏä§ÌÖú Í≤ÄÏ¶ùÏùÑ Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Ïã§ÌñâÌïòÎäî Î£®ÌîÑ"""
        while self.is_running:
            try:
                await asyncio.sleep(3600)  # 1ÏãúÍ∞ÑÎßàÎã§ Ïã§Ìñâ
                
                # ÌÖîÎ†àÍ∑∏Îû® Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
                await self._verify_telegram_connectivity()
                
                # ÏïåÎ¶º Ï†ÑÏÜ° ÏÑ±Í≥µÎ•† Í≤ÄÏ¶ù
                await self._verify_notification_success_rates()
                
                # Ï†ÑÏ≤¥ ÏïåÎ¶º ÏãúÏä§ÌÖú ÏÉÅÌÉú Í≤ÄÏ¶ù
                await self._generate_notification_verification_report()
                
            except Exception as e:
                self.logger.error(f"‚ùå ÏïåÎ¶º Í≤ÄÏ¶ù Î£®ÌîÑ Ïò§Î•ò: {e}")
                await asyncio.sleep(300)  # 5Î∂Ñ ÌõÑ Ïû¨ÏãúÎèÑ
    
    async def _track_notification_delivery(self, msg_obj: Dict, success: bool):
        """ÏïåÎ¶º Ï†ÑÏÜ° Í≤∞Í≥º Ï∂îÏ†Å"""
        try:
            # Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            self.verification_stats['total_notifications_sent'] += 1
            
            if success:
                self.verification_stats['successful_deliveries'] += 1
                self.verification_stats['last_successful_delivery'] = datetime.now()
                self.verification_stats['current_failure_streak'] = 0
            else:
                self.verification_stats['failed_deliveries'] += 1
                self.verification_stats['current_failure_streak'] += 1
                
                # ÏµúÏû• Ïã§Ìå® Ïó∞ÏÜç Í∏∞Î°ù ÏóÖÎç∞Ïù¥Ìä∏
                if self.verification_stats['current_failure_streak'] > self.verification_stats['longest_failure_streak']:
                    self.verification_stats['longest_failure_streak'] = self.verification_stats['current_failure_streak']
            
            # ÏïåÎ¶º Ïú†ÌòïÎ≥Ñ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            notification_type = self._determine_notification_type(msg_obj)
            type_stats = self.verification_stats['notification_types'][notification_type]
            type_stats['sent'] += 1
            
            if success:
                type_stats['success'] += 1
            else:
                type_stats['failed'] += 1
                
        except Exception as e:
            self.logger.error(f"‚ùå ÏïåÎ¶º Ï†ÑÏÜ° Ï∂îÏ†Å Ïò§Î•ò: {e}")
    
    def _determine_notification_type(self, msg_obj: Dict) -> str:
        """Î©îÏãúÏßÄ Í∞ùÏ≤¥ÏóêÏÑú ÏïåÎ¶º Ïú†Ìòï Í≤∞Ï†ï"""
        metadata = msg_obj.get('metadata', {})
        msg_type = metadata.get('type', '')
        
        if msg_type == 'trade':
            return 'trade'
        elif 'error' in msg_obj.get('content', '').lower() or 'Error' in msg_obj.get('content', ''):
            return 'error'
        elif 'ÏúÑÌóò' in msg_obj.get('content', '') or 'Risk' in msg_obj.get('content', ''):
            return 'risk_alert'
        elif 'Î≥¥Í≥†ÏÑú' in msg_obj.get('content', '') or 'Report' in msg_obj.get('content', ''):
            return 'daily_report'
        else:
            return 'system'
    
    async def _verify_telegram_connectivity(self):
        """ÌÖîÎ†àÍ∑∏Îû® Ïó∞Í≤∞ ÏÉÅÌÉú Í≤ÄÏ¶ù"""
        try:
            self.logger.info("üîç ÌÖîÎ†àÍ∑∏Îû® Ïó∞Í≤∞ ÏÉÅÌÉú Í≤ÄÏ¶ù Ï§ë...")
            
            # ÏÑ§Ï†ï ÌôïÏù∏
            if not self.config.TELEGRAM_BOT_TOKEN or not self.config.TELEGRAM_CHAT_ID:
                self.logger.error("‚ùå ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ï ÎàÑÎùΩ")
                return False
            
            # Í∞ÑÎã®Ìïú ÌÖåÏä§Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ°
            test_message = f"üß™ **Ïó∞Í≤∞ ÌÖåÏä§Ìä∏**\n\nÏãúÍ∞Ñ: {datetime.now().strftime('%H:%M:%S')}"
            success = await self._send_telegram_message(test_message, max_retries=2)
            
            if success:
                self.logger.info("‚úÖ ÌÖîÎ†àÍ∑∏Îû® Ïó∞Í≤∞ Ï†ïÏÉÅ")
            else:
                self.logger.error("‚ùå ÌÖîÎ†àÍ∑∏Îû® Ïó∞Í≤∞ Ïã§Ìå®")
                
                # Ïã§Ìå® Ïó∞ÏÜç Í∏∞Î°ùÏù¥ ÎÜíÏúºÎ©¥ Í≤ΩÍ≥†
                if self.verification_stats['current_failure_streak'] >= 5:
                    self.logger.critical(f"üö® ÌÖîÎ†àÍ∑∏Îû® {self.verification_stats['current_failure_streak']}Ìöå Ïó∞ÏÜç Ïã§Ìå®")
            
            return success
            
        except Exception as e:
            self.logger.error(f"‚ùå ÌÖîÎ†àÍ∑∏Îû® Ïó∞Í≤∞ Í≤ÄÏ¶ù Ïò§Î•ò: {e}")
            return False
    
    async def _verify_notification_success_rates(self):
        """ÏïåÎ¶º Ï†ÑÏÜ° ÏÑ±Í≥µÎ•† Í≤ÄÏ¶ù"""
        try:
            total_sent = self.verification_stats['total_notifications_sent']
            if total_sent == 0:
                return
            
            success_rate = self.verification_stats['successful_deliveries'] / total_sent
            
            self.logger.info(f"üìä Ï†ÑÏ≤¥ ÏïåÎ¶º ÏÑ±Í≥µÎ•†: {success_rate:.1%} ({self.verification_stats['successful_deliveries']}/{total_sent})")
            
            # ÏÑ±Í≥µÎ•†Ïù¥ ÎÇÆÏúºÎ©¥ Í≤ΩÍ≥†
            if success_rate < 0.8 and total_sent >= 10:
                self.logger.warning(f"‚ö†Ô∏è ÎÇÆÏùÄ ÏïåÎ¶º ÏÑ±Í≥µÎ•†: {success_rate:.1%}")
                
                # Ïú†ÌòïÎ≥Ñ ÏÑ±Í≥µÎ•† Î∂ÑÏÑù
                problematic_types = []
                for ntype, stats in self.verification_stats['notification_types'].items():
                    if stats['sent'] >= 5:  # Ï∂©Î∂ÑÌïú ÏÉòÌîåÏù¥ ÏûàÎäî Í≤ΩÏö∞Îßå
                        type_success_rate = stats['success'] / stats['sent']
                        if type_success_rate < 0.7:
                            problematic_types.append(f"{ntype}: {type_success_rate:.1%}")
                
                if problematic_types:
                    self.logger.warning(f"‚ö†Ô∏è Î¨∏Ï†úÍ∞Ä ÏûàÎäî ÏïåÎ¶º Ïú†Ìòï: {', '.join(problematic_types)}")
            else:
                self.logger.info("‚úÖ ÏïåÎ¶º Ï†ÑÏÜ° ÏÑ±Í≥µÎ•† ÏñëÌò∏")
                
        except Exception as e:
            self.logger.error(f"‚ùå ÏïåÎ¶º ÏÑ±Í≥µÎ•† Í≤ÄÏ¶ù Ïò§Î•ò: {e}")
    
    async def _generate_notification_verification_report(self):
        """ÏïåÎ¶º ÏãúÏä§ÌÖú Í≤ÄÏ¶ù Î≥¥Í≥†ÏÑú ÏÉùÏÑ±"""
        try:
            stats = self.verification_stats
            total_sent = stats['total_notifications_sent']
            
            if total_sent == 0:
                return
            
            success_rate = stats['successful_deliveries'] / total_sent * 100
            
            # ÎßàÏßÄÎßâ ÏÑ±Í≥µ ÏãúÍ∞Ñ
            last_success = stats['last_successful_delivery']
            last_success_str = last_success.strftime('%H:%M:%S') if last_success else 'ÏóÜÏùå'
            
            report = f"""
üìä ÏïåÎ¶º ÏãúÏä§ÌÖú Í≤ÄÏ¶ù Î≥¥Í≥†ÏÑú
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìà Ï†ÑÏ≤¥ ÏÑ±Í≥µÎ•†: {success_rate:.1f}% ({stats['successful_deliveries']}/{total_sent})
üö´ Ïã§Ìå®Ïú®: {stats['failed_deliveries']/total_sent*100:.1f}%
‚è∞ ÎßàÏßÄÎßâ ÏÑ±Í≥µ: {last_success_str}
üìâ ÌòÑÏû¨ Ïó∞ÏÜç Ïã§Ìå®: {stats['current_failure_streak']}Ìöå
üìä ÏµúÏû• Ïó∞ÏÜç Ïã§Ìå®: {stats['longest_failure_streak']}Ìöå

üìã ÏïåÎ¶º Ïú†ÌòïÎ≥Ñ ÏÑ±Í≥µÎ•†:"""
            
            for ntype, type_stats in stats['notification_types'].items():
                if type_stats['sent'] > 0:
                    type_success_rate = type_stats['success'] / type_stats['sent'] * 100
                    report += f"\n  ‚Ä¢ {ntype.title()}: {type_success_rate:.1f}% ({type_stats['success']}/{type_stats['sent']})"
            
            # ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ï ÏÉÅÌÉú
            telegram_configured = bool(self.config.TELEGRAM_BOT_TOKEN and self.config.TELEGRAM_CHAT_ID)
            report += f"\n\nüîß ÏÑ§Ï†ï ÏÉÅÌÉú:\n  ‚Ä¢ ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ï: {'‚úÖ ÏôÑÎ£å' if telegram_configured else '‚ùå ÎØ∏ÏôÑÎ£å'}"
            
            # ÌÅê ÏÉÅÌÉú
            emergency_queue_size = self.emergency_queue.qsize()
            normal_queue_size = self.normal_queue.qsize()
            report += f"\n  ‚Ä¢ Í∏¥Í∏â ÌÅê: {emergency_queue_size}Í∞ú ÎåÄÍ∏∞"
            report += f"\n  ‚Ä¢ ÏùºÎ∞ò ÌÅê: {normal_queue_size}Í∞ú ÎåÄÍ∏∞"
            
            self.logger.info(report)
            
            # Ïã¨Í∞ÅÌïú Î¨∏Ï†úÍ∞Ä ÏûàÏúºÎ©¥ ÏûêÍ∞Ä ÏßÑÎã® ÏïåÎ¶º Î∞úÏÜ°
            if success_rate < 70 and total_sent >= 5:
                critical_alert = f"""üö® **ÏïåÎ¶º ÏãúÏä§ÌÖú Î¨∏Ï†ú Í∞êÏßÄ**
                
ÏÑ±Í≥µÎ•†: {success_rate:.1f}%
Ïó∞ÏÜç Ïã§Ìå®: {stats['current_failure_streak']}Ìöå
                
Ï¶âÏãú ÌôïÏù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§."""
                
                # ÏßÅÏ†ë ÌÖîÎ†àÍ∑∏Îû®ÏúºÎ°ú Ï†ÑÏÜ° ÏãúÎèÑ
                try:
                    await self._send_telegram_message(critical_alert, max_retries=3)
                except Exception as e:
                    self.logger.critical(f"üö® ÏûêÍ∞Ä ÏßÑÎã® ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {e}")
                    
        except Exception as e:
            self.logger.error(f"‚ùå ÏïåÎ¶º Í≤ÄÏ¶ù Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ïò§Î•ò: {e}")
    
    async def verify_all_notification_points(self):
        """Î™®Îì† ÏïåÎ¶º ÏßÄÏ†ê Í≤ÄÏ¶ù (ÏàòÎèô Ìò∏Ï∂úÏö©)"""
        self.logger.info("üîç Î™®Îì† ÏïåÎ¶º ÏßÄÏ†ê Í≤ÄÏ¶ù ÏãúÏûë...")
        
        notification_points = [
            {
                'type': 'system_startup',
                'test_message': 'üöÄ **ÏãúÏä§ÌÖú ÏãúÏûë ÌÖåÏä§Ìä∏**\n\nÍ≤ÄÏ¶ùÏö© ÏãúÏûë ÏïåÎ¶º',
                'expected_priority': 'high'
            },
            {
                'type': 'trade_notification', 
                'test_message': 'üí∞ **Í±∞Îûò ÏïåÎ¶º ÌÖåÏä§Ìä∏**\n\nBTCUSDT Î°± Ìè¨ÏßÄÏÖò ÏßÑÏûÖ\nÍ∞ÄÍ≤©: $50,000',
                'expected_priority': 'high'
            },
            {
                'type': 'error_notification',
                'test_message': '‚ùå **Ïò§Î•ò ÏïåÎ¶º ÌÖåÏä§Ìä∏**\n\nÌÖåÏä§Ìä∏Ïö© Ïò§Î•ò Î©îÏãúÏßÄ',
                'expected_priority': 'high'
            },
            {
                'type': 'risk_alert',
                'test_message': '‚ö†Ô∏è **ÏúÑÌóò ÏïåÎ¶º ÌÖåÏä§Ìä∏**\n\nÏùºÏùº ÏÜêÏã§ ÌïúÍ≥Ñ Í∑ºÏ†ë',
                'expected_priority': 'high'
            },
            {
                'type': 'daily_report',
                'test_message': 'üìä **ÏùºÏùº Î≥¥Í≥†ÏÑú ÌÖåÏä§Ìä∏**\n\nÏÑ±Í≥º: +2.5%\nÍ±∞Îûò: 3Ìöå ÏÑ±Í≥µ',
                'expected_priority': 'normal'
            }
        ]
        
        results = {}
        for point in notification_points:
            try:
                self.logger.info(f"ÌÖåÏä§Ìä∏ Ï§ë: {point['type']}")
                success = await self._send_telegram_message(point['test_message'], max_retries=2)
                results[point['type']] = success
                await asyncio.sleep(2)  # Rate limiting
            except Exception as e:
                self.logger.error(f"{point['type']} ÌÖåÏä§Ìä∏ Ïã§Ìå®: {e}")
                results[point['type']] = False
        
        # Í≤∞Í≥º ÏöîÏïΩ
        successful_tests = sum(1 for success in results.values() if success)
        total_tests = len(results)
        
        summary = f"""
üß™ **ÏïåÎ¶º ÏßÄÏ†ê Í≤ÄÏ¶ù ÏôÑÎ£å**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚úÖ ÏÑ±Í≥µ: {successful_tests}/{total_tests}
        
ÏÉÅÏÑ∏ Í≤∞Í≥º:"""
        
        for test_type, success in results.items():
            status = "‚úÖ ÏÑ±Í≥µ" if success else "‚ùå Ïã§Ìå®"
            summary += f"\n  ‚Ä¢ {test_type}: {status}"
        
        self.logger.info(summary)
        
        # Í≤ÄÏ¶ù Í≤∞Í≥ºÎ•º ÌÖîÎ†àÍ∑∏Îû®ÏúºÎ°ú Ï†ÑÏÜ°
        if successful_tests > 0:  # ÏµúÏÜåÌïú ÌïòÎÇòÎùºÎèÑ ÏûëÎèôÌïòÎ©¥ Í≤∞Í≥º Ï†ÑÏÜ°
            try:
                await self._send_telegram_message(summary, max_retries=3)
            except Exception as e:
                self.logger.error(f"Í≤ÄÏ¶ù Í≤∞Í≥º Ï†ÑÏÜ° Ïã§Ìå®: {e}")
        
        return results
    
    async def shutdown(self):
        """Shutdown notification system"""
        self.logger.info("üîÑ ÏïåÎ¶º ÏãúÏä§ÌÖú Ï¢ÖÎ£å Ï§ë...")
        self.is_running = False
        
        if self.processor_task:
            try:
                await asyncio.wait_for(self.processor_task, timeout=5.0)
            except asyncio.TimeoutError:
                self.logger.warning("ÏïåÎ¶º ÌîÑÎ°úÏÑ∏ÏÑú Ï¢ÖÎ£å ÌÉÄÏûÑÏïÑÏõÉ")
                self.processor_task.cancel()
        
        if self.notification_verification_task:
            try:
                await asyncio.wait_for(self.notification_verification_task, timeout=5.0)
            except asyncio.TimeoutError:
                self.logger.warning("ÏïåÎ¶º Í≤ÄÏ¶ù ÌîÑÎ°úÏÑ∏ÏÑú Ï¢ÖÎ£å ÌÉÄÏûÑÏïÑÏõÉ")
                self.notification_verification_task.cancel()
        
        self.logger.info("‚úÖ ÏïåÎ¶º ÏãúÏä§ÌÖú Ï¢ÖÎ£å ÏôÑÎ£å")