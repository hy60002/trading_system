import { BaseComponent } from '../core/BaseComponent.js';

/**
 * Í∞ïÌôîÎêú WebSocket ÏÑúÎπÑÏä§
 * - ÏßÄÏàò Î∞±Ïò§ÌîÑ Ïû¨Ïó∞Í≤∞
 * - Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ
 * - ÌïòÌä∏ÎπÑÌä∏ Î©îÏª§ÎãàÏ¶ò
 * - Î©îÏãúÏßÄ ÏàúÏÑú Î≥¥Ïû•
 * - ÏûêÎèô Íµ¨ÎèÖ Î≥µÍµ¨
 */
export class EnhancedWebSocketService extends BaseComponent {
    constructor(options = {}) {
        super(null, options);
        
        // Ïó∞Í≤∞ ÏÑ§Ï†ï
        this.wsUrl = options.wsUrl || 'wss://stream.bitget.com/mix/v1/stream';
        this.protocols = options.protocols || [];
        this.ws = null;
        
        // Ïó∞Í≤∞ ÏÉÅÌÉú
        this.connectionState = {
            status: 'disconnected', // disconnected, connecting, connected, reconnecting, error
            lastConnected: null,
            lastDisconnected: null,
            totalConnections: 0,
            totalDisconnections: 0
        };
        
        // Ïû¨Ïó∞Í≤∞ ÏÑ§Ï†ï (ÏßÄÏàò Î∞±Ïò§ÌîÑ)
        this.reconnectConfig = {
            enabled: options.reconnect !== false,
            attempts: 0,
            maxAttempts: options.maxReconnectAttempts || 10,
            baseDelay: options.baseReconnectDelay || 1000, // 1Ï¥à
            maxDelay: options.maxReconnectDelay || 30000,   // 30Ï¥à
            backoffFactor: options.backoffFactor || 2,
            jitter: options.jitter !== false
        };
        
        // ÌïòÌä∏ÎπÑÌä∏ ÏÑ§Ï†ï
        this.heartbeat = {
            enabled: options.heartbeat !== false,
            interval: options.heartbeatInterval || 30000,  // 30Ï¥à
            timeout: options.heartbeatTimeout || 10000,    // 10Ï¥à
            intervalId: null,
            timeoutId: null,
            lastPong: null,
            missedPongs: 0,
            maxMissedPongs: options.maxMissedPongs || 3
        };
        
        // Î©îÏãúÏßÄ Í¥ÄÎ¶¨
        this.messageQueue = [];
        this.pendingMessages = new Map(); // ÏùëÎãµ ÎåÄÍ∏∞ Î©îÏãúÏßÄ
        this.messageId = 0;
        this.maxQueueSize = options.maxQueueSize || 1000;
        
        // Íµ¨ÎèÖ Í¥ÄÎ¶¨
        this.subscriptions = new Map();
        this.autoResubscribe = options.autoResubscribe !== false;
        
        // Î©îÏãúÏßÄ ÏàúÏÑú Î≥¥Ïû•
        this.sequenceNumber = 0;
        this.receivedSequences = new Set();
        this.outOfOrderBuffer = new Map();
        
        // ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
        this.metrics = {
            messagesReceived: 0,
            messagesSent: 0,
            bytesReceived: 0,
            bytesSent: 0,
            averageLatency: 0,
            latencyHistory: [],
            errorCount: 0,
            reconnectCount: 0,
            uptime: 0,
            lastUptimeCheck: Date.now()
        };
        
        // Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
        this.eventHandlers = {
            onOpen: null,
            onMessage: null,
            onClose: null,
            onError: null,
            onReconnect: null
        };
        
        // Ïó∞Í≤∞ ÌíàÏßà Í¥ÄÎ¶¨
        this.connectionQuality = {
            score: 100, // 0-100
            latency: 0,
            stability: 100,
            throughput: 0
        };
        
        this.init();
    }
    
    /**
     * Ï¥àÍ∏∞Ìôî
     */
    init() {
        this.setupConnectionMonitoring();
        this.startMetricsCollection();
        this.emit('webSocketServiceInitialized');
    }
    
    /**
     * WebSocket Ïó∞Í≤∞
     */
    async connect() {
        if (this.connectionState.status === 'connected' || 
            this.connectionState.status === 'connecting') {
            return;
        }
        
        try {
            this.connectionState.status = 'connecting';
            this.emit('connectionStateChanged', 'connecting');
            
            // WebSocket Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
            this.ws = new WebSocket(this.wsUrl, this.protocols);
            this.setupWebSocketEventHandlers();
            
            // Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
            const connectTimeout = setTimeout(() => {
                if (this.connectionState.status === 'connecting') {
                    this.ws.close();
                    this.handleConnectionError(new Error('Connection timeout'));
                }
            }, 10000);
            
            // Ïó∞Í≤∞ ÏÑ±Í≥µ Ïãú ÌÉÄÏûÑÏïÑÏõÉ ÌÅ¥Î¶¨Ïñ¥
            this.ws.addEventListener('open', () => {
                clearTimeout(connectTimeout);
            }, { once: true });
            
        } catch (error) {
            this.handleConnectionError(error);
        }
    }
    
    /**
     * WebSocket Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ ÏÑ§Ï†ï
     */
    setupWebSocketEventHandlers() {
        this.ws.onopen = (event) => {
            this.handleConnectionOpen(event);
        };
        
        this.ws.onmessage = (event) => {
            this.handleMessage(event);
        };
        
        this.ws.onclose = (event) => {
            this.handleConnectionClose(event);
        };
        
        this.ws.onerror = (event) => {
            this.handleConnectionError(event);
        };
    }
    
    /**
     * Ïó∞Í≤∞ ÏÑ±Í≥µ Ï≤òÎ¶¨
     */
    handleConnectionOpen(event) {
        console.log('‚úÖ WebSocket connected');
        
        // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        this.connectionState.status = 'connected';
        this.connectionState.lastConnected = Date.now();
        this.connectionState.totalConnections++;
        
        // Ïû¨Ïó∞Í≤∞ Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã
        this.reconnectConfig.attempts = 0;
        
        // ÌÅêÎêú Î©îÏãúÏßÄ Ï†ÑÏÜ°
        this.flushMessageQueue();
        
        // ÌïòÌä∏ÎπÑÌä∏ ÏãúÏûë
        this.startHeartbeat();
        
        // Íµ¨ÎèÖ Î≥µÍµ¨
        if (this.autoResubscribe && this.metrics.reconnectCount > 0) {
            this.resubscribeAll();
        }
        
        // Ïù¥Î≤§Ìä∏ Î∞úÏÉù
        this.emit('connectionStateChanged', 'connected');
        this.emit('connected', event);
        
        if (this.eventHandlers.onOpen) {
            this.eventHandlers.onOpen(event);
        }
        
        // Ïó∞Í≤∞ ÌíàÏßà Ï¥àÍ∏∞Ìôî
        this.connectionQuality.score = 100;
        this.updateConnectionMetrics();
    }
    
    /**
     * Î©îÏãúÏßÄ ÏàòÏã† Ï≤òÎ¶¨
     */
    handleMessage(event) {
        try {
            const startTime = performance.now();
            const data = JSON.parse(event.data);
            
            // Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
            this.metrics.messagesReceived++;
            this.metrics.bytesReceived += event.data.length;
            
            // ÌïòÌä∏ÎπÑÌä∏ ÏùëÎãµ Ï≤òÎ¶¨
            if (this.isHeartbeatResponse(data)) {
                this.handleHeartbeatResponse(data);
                return;
            }
            
            // ÏãúÌÄÄÏä§ Î≤àÌò∏ ÌôïÏù∏ (ÏàúÏÑú Î≥¥Ïû•)
            if (data.sequence && this.isValidSequence(data.sequence)) {
                this.processMessage(data);
            } else if (data.sequence) {
                this.bufferOutOfOrderMessage(data);
            } else {
                // ÏãúÌÄÄÏä§ Î≤àÌò∏Í∞Ä ÏóÜÎäî Î©îÏãúÏßÄÎäî Î∞îÎ°ú Ï≤òÎ¶¨
                this.processMessage(data);
            }
            
            // ÏßÄÏó∞ÏãúÍ∞Ñ Í≥ÑÏÇ∞
            const processingTime = performance.now() - startTime;
            this.updateLatencyMetrics(processingTime);
            
            // Ïó∞Í≤∞ ÌíàÏßà ÏóÖÎç∞Ïù¥Ìä∏
            this.updateConnectionQuality();
            
        } catch (error) {
            this.metrics.errorCount++;
            this.emit('messageError', { error, rawData: event.data });
            console.error('Message processing error:', error);
        }
    }
    
    /**
     * Î©îÏãúÏßÄ Ï≤òÎ¶¨
     */
    processMessage(data) {
        // Ïù¥Î≤§Ìä∏ Î∞úÏÉù
        this.emit('message', data);
        
        if (this.eventHandlers.onMessage) {
            this.eventHandlers.onMessage(data);
        }
        
        // ÏùëÎãµ ÎåÄÍ∏∞ Î©îÏãúÏßÄ ÌôïÏù∏
        if (data.id && this.pendingMessages.has(data.id)) {
            const pending = this.pendingMessages.get(data.id);
            clearTimeout(pending.timeout);
            this.pendingMessages.delete(data.id);
            
            if (pending.resolve) {
                pending.resolve(data);
            }
        }
    }
    
    /**
     * Ïó∞Í≤∞ Ï¢ÖÎ£å Ï≤òÎ¶¨
     */
    handleConnectionClose(event) {
        console.warn('üîå WebSocket disconnected:', event.code, event.reason);
        
        // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        this.connectionState.status = 'disconnected';
        this.connectionState.lastDisconnected = Date.now();
        this.connectionState.totalDisconnections++;
        
        // ÌïòÌä∏ÎπÑÌä∏ Ï§ëÏßÄ
        this.stopHeartbeat();
        
        // ÎåÄÍ∏∞ Ï§ëÏù∏ Î©îÏãúÏßÄÎì§ ÌÉÄÏûÑÏïÑÏõÉ Ï≤òÎ¶¨
        this.timeoutPendingMessages();
        
        // Ïù¥Î≤§Ìä∏ Î∞úÏÉù
        this.emit('connectionStateChanged', 'disconnected');
        this.emit('disconnected', event);
        
        if (this.eventHandlers.onClose) {
            this.eventHandlers.onClose(event);
        }
        
        // ÏûêÎèô Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
        if (this.reconnectConfig.enabled && !this.isIntentionalClose(event.code)) {
            this.scheduleReconnect();
        }
        
        // Ïó∞Í≤∞ ÌíàÏßà Ï†ÄÌïò
        this.connectionQuality.score = 0;
    }
    
    /**
     * Ïó∞Í≤∞ ÏóêÎü¨ Ï≤òÎ¶¨
     */
    handleConnectionError(event) {
        console.error('‚ùå WebSocket error:', event);
        
        this.metrics.errorCount++;
        this.connectionState.status = 'error';
        
        // Ïù¥Î≤§Ìä∏ Î∞úÏÉù
        this.emit('connectionStateChanged', 'error');
        this.emit('error', event);
        
        if (this.eventHandlers.onError) {
            this.eventHandlers.onError(event);
        }
    }
    
    /**
     * Ïû¨Ïó∞Í≤∞ Ïä§ÏºÄÏ§ÑÎßÅ (ÏßÄÏàò Î∞±Ïò§ÌîÑ)
     */
    scheduleReconnect() {
        if (this.reconnectConfig.attempts >= this.reconnectConfig.maxAttempts) {
            console.error('‚ùå Maximum reconnect attempts reached');
            this.emit('maxReconnectAttemptsReached');
            return;
        }
        
        this.connectionState.status = 'reconnecting';
        this.emit('connectionStateChanged', 'reconnecting');
        
        // ÏßÄÏàò Î∞±Ïò§ÌîÑ Í≥ÑÏÇ∞
        const delay = this.calculateReconnectDelay();
        
        console.log(`üîÑ Reconnecting in ${delay}ms (attempt ${this.reconnectConfig.attempts + 1})`);
        
        setTimeout(() => {
            this.reconnectConfig.attempts++;
            this.metrics.reconnectCount++;
            
            this.emit('reconnectAttempt', {
                attempt: this.reconnectConfig.attempts,
                delay: delay
            });
            
            this.connect();
        }, delay);
    }
    
    /**
     * Ïû¨Ïó∞Í≤∞ ÏßÄÏó∞ ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (ÏßÄÏàò Î∞±Ïò§ÌîÑ + ÏßÄÌÑ∞)
     */
    calculateReconnectDelay() {
        let delay = this.reconnectConfig.baseDelay * 
                   Math.pow(this.reconnectConfig.backoffFactor, this.reconnectConfig.attempts);
        
        // ÏµúÎåÄ ÏßÄÏó∞ ÏãúÍ∞Ñ Ï†úÌïú
        delay = Math.min(delay, this.reconnectConfig.maxDelay);
        
        // ÏßÄÌÑ∞ Ï∂îÍ∞Ä (ÎûúÎç§ÏÑ±)
        if (this.reconnectConfig.jitter) {
            const jitterAmount = delay * 0.1; // 10% ÏßÄÌÑ∞
            delay += (Math.random() - 0.5) * 2 * jitterAmount;
        }
        
        return Math.max(0, Math.floor(delay));
    }
    
    /**
     * ÌïòÌä∏ÎπÑÌä∏ ÏãúÏûë
     */
    startHeartbeat() {
        if (!this.heartbeat.enabled) return;
        
        this.stopHeartbeat(); // Í∏∞Ï°¥ ÌïòÌä∏ÎπÑÌä∏ Ï§ëÏßÄ
        
        this.heartbeat.intervalId = setInterval(() => {
            this.sendHeartbeat();
        }, this.heartbeat.interval);
    }
    
    /**
     * ÌïòÌä∏ÎπÑÌä∏ Ï†ÑÏÜ°
     */
    sendHeartbeat() {
        if (this.connectionState.status !== 'connected') return;
        
        const heartbeatMessage = {
            type: 'ping',
            timestamp: Date.now()
        };
        
        this.send(heartbeatMessage, false); // ÌÅêÏóê Ï†ÄÏû•ÌïòÏßÄ ÏïäÏùå
        
        // ÏùëÎãµ ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
        this.heartbeat.timeoutId = setTimeout(() => {
            this.handleHeartbeatTimeout();
        }, this.heartbeat.timeout);
    }
    
    /**
     * ÌïòÌä∏ÎπÑÌä∏ ÏùëÎãµ Ï≤òÎ¶¨
     */
    handleHeartbeatResponse(data) {
        if (this.heartbeat.timeoutId) {
            clearTimeout(this.heartbeat.timeoutId);
            this.heartbeat.timeoutId = null;
        }
        
        this.heartbeat.lastPong = Date.now();
        this.heartbeat.missedPongs = 0;
        
        // ÏßÄÏó∞ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
        if (data.timestamp) {
            const latency = Date.now() - data.timestamp;
            this.connectionQuality.latency = latency;
        }
    }
    
    /**
     * ÌïòÌä∏ÎπÑÌä∏ ÌÉÄÏûÑÏïÑÏõÉ Ï≤òÎ¶¨
     */
    handleHeartbeatTimeout() {
        this.heartbeat.missedPongs++;
        
        console.warn(`‚ö†Ô∏è Heartbeat missed (${this.heartbeat.missedPongs}/${this.heartbeat.maxMissedPongs})`);
        
        if (this.heartbeat.missedPongs >= this.heartbeat.maxMissedPongs) {
            console.error('üíî Too many missed heartbeats, closing connection');
            this.ws.close(1000, 'Heartbeat timeout');
        }
    }
    
    /**
     * ÌïòÌä∏ÎπÑÌä∏ Ï§ëÏßÄ
     */
    stopHeartbeat() {
        if (this.heartbeat.intervalId) {
            clearInterval(this.heartbeat.intervalId);
            this.heartbeat.intervalId = null;
        }
        
        if (this.heartbeat.timeoutId) {
            clearTimeout(this.heartbeat.timeoutId);
            this.heartbeat.timeoutId = null;
        }
        
        this.heartbeat.missedPongs = 0;
    }
    
    /**
     * Î©îÏãúÏßÄ Ï†ÑÏÜ°
     */
    send(message, queueIfDisconnected = true) {
        if (this.connectionState.status === 'connected') {
            return this.sendImmediate(message);
        } else if (queueIfDisconnected) {
            return this.queueMessage(message);
        } else {
            throw new Error('WebSocket not connected');
        }
    }
    
    /**
     * Ï¶âÏãú Î©îÏãúÏßÄ Ï†ÑÏÜ°
     */
    sendImmediate(message) {
        try {
            // Î©îÏãúÏßÄ ID Ï∂îÍ∞Ä
            if (!message.id) {
                message.id = this.generateMessageId();
            }
            
            // ÏãúÌÄÄÏä§ Î≤àÌò∏ Ï∂îÍ∞Ä (ÏàúÏÑú Î≥¥Ïû•Ïö©)
            if (!message.sequence) {
                message.sequence = ++this.sequenceNumber;
            }
            
            const messageString = JSON.stringify(message);
            this.ws.send(messageString);
            
            // Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
            this.metrics.messagesSent++;
            this.metrics.bytesSent += messageString.length;
            
            this.emit('messageSent', message);
            
            return message.id;
            
        } catch (error) {
            this.metrics.errorCount++;
            this.emit('sendError', { error, message });
            throw error;
        }
    }
    
    /**
     * Î©îÏãúÏßÄ ÌÅêÏóê Ï∂îÍ∞Ä
     */
    queueMessage(message) {
        if (this.messageQueue.length >= this.maxQueueSize) {
            // Í∞ÄÏû• Ïò§ÎûòÎêú Î©îÏãúÏßÄ Ï†úÍ±∞
            this.messageQueue.shift();
            console.warn('‚ö†Ô∏è Message queue overflow, removing oldest message');
        }
        
        const queuedMessage = {
            ...message,
            id: message.id || this.generateMessageId(),
            queuedAt: Date.now()
        };
        
        this.messageQueue.push(queuedMessage);
        this.emit('messageQueued', queuedMessage);
        
        return queuedMessage.id;
    }
    
    /**
     * ÌÅêÎêú Î©îÏãúÏßÄ Î™®Îëê Ï†ÑÏÜ°
     */
    flushMessageQueue() {
        if (this.messageQueue.length === 0) return;
        
        console.log(`üì§ Flushing ${this.messageQueue.length} queued messages`);
        
        const messages = [...this.messageQueue];
        this.messageQueue = [];
        
        messages.forEach(message => {
            try {
                this.sendImmediate(message);
            } catch (error) {
                console.error('Failed to send queued message:', error);
                // Ïã§Ìå®Ìïú Î©îÏãúÏßÄÎäî Îã§Ïãú ÌÅêÏóê Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå
            }
        });
    }
    
    /**
     * ÏùëÎãµ ÎåÄÍ∏∞ Î©îÏãúÏßÄ Ï†ÑÏÜ°
     */
    sendAndWaitForResponse(message, timeout = 30000) {
        const messageId = this.send(message);
        
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                this.pendingMessages.delete(messageId);
                reject(new Error('Response timeout'));
            }, timeout);
            
            this.pendingMessages.set(messageId, {
                resolve,
                reject,
                timeout: timeoutId,
                sentAt: Date.now()
            });
        });
    }
    
    /**
     * Íµ¨ÎèÖ Í¥ÄÎ¶¨
     */
    subscribe(subscription) {
        const subId = subscription.id || this.generateSubscriptionId();
        this.subscriptions.set(subId, {
            ...subscription,
            id: subId,
            subscribedAt: Date.now()
        });
        
        const message = {
            op: 'subscribe',
            args: subscription.args || subscription
        };
        
        this.send(message);
        this.emit('subscribed', subId);
        
        return subId;
    }
    
    /**
     * Íµ¨ÎèÖ Ìï¥Ï†ú
     */
    unsubscribe(subscriptionId) {
        const subscription = this.subscriptions.get(subscriptionId);
        if (!subscription) return;
        
        const message = {
            op: 'unsubscribe',
            args: subscription.args || subscription
        };
        
        this.send(message);
        this.subscriptions.delete(subscriptionId);
        this.emit('unsubscribed', subscriptionId);
    }
    
    /**
     * Î™®Îì† Íµ¨ÎèÖ Î≥µÍµ¨
     */
    resubscribeAll() {
        console.log(`üîÑ Resubscribing ${this.subscriptions.size} subscriptions`);
        
        for (const [id, subscription] of this.subscriptions) {
            const message = {
                op: 'subscribe',
                args: subscription.args || subscription
            };
            
            this.send(message);
        }
        
        this.emit('resubscribedAll');
    }
    
    /**
     * Ïó∞Í≤∞ Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
     */
    setupConnectionMonitoring() {
        setInterval(() => {
            this.updateConnectionMetrics();
            this.checkConnectionHealth();
        }, 5000); // 5Ï¥àÎßàÎã§
    }
    
    /**
     * Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
     */
    checkConnectionHealth() {
        if (this.connectionState.status === 'connected') {
            // ÏµúÍ∑º Î©îÏãúÏßÄ ÏàòÏã† ÌôïÏù∏
            const timeSinceLastMessage = Date.now() - (this.heartbeat.lastPong || this.connectionState.lastConnected);
            
            if (timeSinceLastMessage > this.heartbeat.interval * 2) {
                console.warn('‚ö†Ô∏è No recent activity detected, connection may be stale');
                this.connectionQuality.score = Math.max(0, this.connectionQuality.score - 10);
            }
        }
    }
    
    /**
     * Ïó∞Í≤∞ ÌíàÏßà ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateConnectionQuality() {
        if (this.connectionState.status === 'connected') {
            // ÏßÄÏó∞ÏãúÍ∞Ñ Í∏∞Î∞ò Ï†êÏàò
            const latencyScore = Math.max(0, 100 - (this.connectionQuality.latency / 10));
            
            // ÏïàÏ†ïÏÑ± Ï†êÏàò (Ïû¨Ïó∞Í≤∞ ÌöüÏàò Í∏∞Î∞ò)
            const stabilityPenalty = this.metrics.reconnectCount * 5;
            const stabilityScore = Math.max(0, 100 - stabilityPenalty);
            
            // Ï†ÑÏ≤¥ Ï†êÏàò Í≥ÑÏÇ∞
            this.connectionQuality.score = Math.round((latencyScore + stabilityScore) / 2);
            this.connectionQuality.stability = stabilityScore;
        }
        
        this.emit('connectionQualityUpdated', this.connectionQuality);
    }
    
    /**
     * Î©îÌä∏Î¶≠ ÏàòÏßë ÏãúÏûë
     */
    startMetricsCollection() {
        setInterval(() => {
            this.updateUptimeMetrics();
            this.emit('metricsUpdated', this.getMetrics());
        }, 60000); // 1Î∂ÑÎßàÎã§
    }
    
    /**
     * ÏóÖÌÉÄÏûÑ Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateUptimeMetrics() {
        if (this.connectionState.status === 'connected') {
            const now = Date.now();
            this.metrics.uptime += now - this.metrics.lastUptimeCheck;
            this.metrics.lastUptimeCheck = now;
        }
    }
    
    /**
     * ÏßÄÏó∞ÏãúÍ∞Ñ Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateLatencyMetrics(latency) {
        this.metrics.latencyHistory.push(latency);
        
        // ÏµúÍ∑º 100Í∞ú Í∏∞Î°ùÎßå Ïú†ÏßÄ
        if (this.metrics.latencyHistory.length > 100) {
            this.metrics.latencyHistory.shift();
        }
        
        // ÌèâÍ∑† ÏßÄÏó∞ÏãúÍ∞Ñ Í≥ÑÏÇ∞
        const sum = this.metrics.latencyHistory.reduce((a, b) => a + b, 0);
        this.metrics.averageLatency = sum / this.metrics.latencyHistory.length;
    }
    
    /**
     * Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
     */
    generateMessageId() {
        return `msg_${++this.messageId}_${Date.now()}`;
    }
    
    generateSubscriptionId() {
        return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    isHeartbeatResponse(data) {
        return data.type === 'pong' || data.pong !== undefined;
    }
    
    isIntentionalClose(code) {
        return code === 1000 || code === 1001;
    }
    
    isValidSequence(sequence) {
        return sequence === this.expectedSequence;
    }
    
    bufferOutOfOrderMessage(data) {
        this.outOfOrderBuffer.set(data.sequence, data);
        
        // Î≤ÑÌçº ÌÅ¨Í∏∞ Ï†úÌïú
        if (this.outOfOrderBuffer.size > 100) {
            const oldestSequence = Math.min(...this.outOfOrderBuffer.keys());
            this.outOfOrderBuffer.delete(oldestSequence);
        }
    }
    
    timeoutPendingMessages() {
        for (const [id, pending] of this.pendingMessages) {
            clearTimeout(pending.timeout);
            if (pending.reject) {
                pending.reject(new Error('Connection closed'));
            }
        }
        this.pendingMessages.clear();
    }
    
    /**
     * Ïô∏Î∂Ä API
     */
    
    // Ïó∞Í≤∞ ÏÉÅÌÉú Ï°∞Ìöå
    getConnectionState() {
        return {
            ...this.connectionState,
            isConnected: this.connectionState.status === 'connected',
            quality: this.connectionQuality
        };
    }
    
    // Î©îÌä∏Î¶≠ Ï°∞Ìöå
    getMetrics() {
        return {
            ...this.metrics,
            connectionState: this.connectionState,
            quality: this.connectionQuality,
            subscriptions: this.subscriptions.size,
            queueSize: this.messageQueue.length
        };
    }
    
    // Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ ÏÑ§Ï†ï
    on(event, handler) {
        if (this.eventHandlers.hasOwnProperty(`on${event.charAt(0).toUpperCase()}${event.slice(1)}`)) {
            this.eventHandlers[`on${event.charAt(0).toUpperCase()}${event.slice(1)}`] = handler;
        }
        super.on(event, handler);
    }
    
    // Í∞ïÏ†ú Ïû¨Ïó∞Í≤∞
    forceReconnect() {
        if (this.ws) {
            this.ws.close(1000, 'Force reconnect');
        }
        
        setTimeout(() => {
            this.connect();
        }, 100);
    }
    
    // Ïó∞Í≤∞ Ï¢ÖÎ£å
    disconnect() {
        this.reconnectConfig.enabled = false;
        
        if (this.ws) {
            this.ws.close(1000, 'Manual disconnect');
        }
        
        this.stopHeartbeat();
    }
    
    // Î©îÌä∏Î¶≠ Î¶¨ÏÖã
    resetMetrics() {
        this.metrics = {
            messagesReceived: 0,
            messagesSent: 0,
            bytesReceived: 0,
            bytesSent: 0,
            averageLatency: 0,
            latencyHistory: [],
            errorCount: 0,
            reconnectCount: 0,
            uptime: 0,
            lastUptimeCheck: Date.now()
        };
    }
    
    /**
     * Ï†ïÎ¶¨
     */
    destroy() {
        this.disconnect();
        this.subscriptions.clear();
        this.messageQueue = [];
        this.pendingMessages.clear();
        
        super.destroy();
    }
}

export default EnhancedWebSocketService;