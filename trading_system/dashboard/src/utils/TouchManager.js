/**
 * üì± TouchManager.js - ÏôÑÏ†ÑÌïú Î™®Î∞îÏùº ÌÑ∞Ïπò Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú
 * Ïä§ÏôÄÏù¥ÌîÑ, ÌïÄÏπòÏ§å, ÌöåÏ†Ñ, ÎçîÎ∏îÌÉ≠, Î°±ÌîÑÎ†àÏä§, ÌñÖÌã± ÌîºÎìúÎ∞± ÏßÄÏõê
 * 763 lines - DASHBOARD_IMPROVEMENT_COMPLETE.md ÏöîÍµ¨ÏÇ¨Ìï≠
 */

class TouchManager {
    constructor() {
        this.touchStartTime = 0;
        this.touchStartPos = { x: 0, y: 0 };
        this.lastTouchTime = 0;
        this.lastTouchPos = { x: 0, y: 0 };
        this.touches = new Map();
        this.gestureCallbacks = new Map();
        this.isEnabled = true;
        
        // Ï†úÏä§Ï≤ò ÏÑ§Ï†ï
        this.config = {
            // Ïä§ÏôÄÏù¥ÌîÑ
            swipe: {
                minDistance: 50,
                maxTime: 300,
                maxDeviation: 100
            },
            
            // ÎçîÎ∏î ÌÉ≠
            doubleTap: {
                maxDelay: 300,
                maxDistance: 20
            },
            
            // Î°± ÌîÑÎ†àÏä§
            longPress: {
                duration: 500,
                maxMovement: 10
            },
            
            // ÌïÄÏπò Ï§å
            pinch: {
                minScale: 0.5,
                maxScale: 3.0,
                threshold: 10
            },
            
            // ÌöåÏ†Ñ
            rotate: {
                threshold: 5 // degrees
            },
            
            // Ìå¨
            pan: {
                threshold: 5
            }
        };
        
        // ÏßÄÏõêÎêòÎäî Ï†úÏä§Ï≤ò ÌÉÄÏûÖ
        this.gestureTypes = [
            'tap',
            'doubleTap',
            'longPress',
            'swipeUp',
            'swipeDown',
            'swipeLeft',
            'swipeRight',
            'pinchIn',
            'pinchOut',
            'rotate',
            'pan',
            'panStart',
            'panMove',
            'panEnd'
        ];
        
        // ÌòÑÏû¨ Ï†úÏä§Ï≤ò ÏÉÅÌÉú
        this.currentGesture = null;
        this.gestureState = {
            scale: 1,
            rotation: 0,
            translation: { x: 0, y: 0 }
        };
        
        // ÌÉÄÏù¥Î®∏ Í¥ÄÎ¶¨
        this.longPressTimer = null;
        this.doubleTapTimer = null;
        
        this.init();
    }
    
    /**
     * Touch Manager Ï¥àÍ∏∞Ìôî
     */
    init() {
        // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
        this.addEventListeners();
        
        // ÎîîÎ∞îÏù¥Ïä§ Í∞êÏßÄ
        this.detectDevice();
        
        // ÌñÖÌã± ÌîºÎìúÎ∞± ÏßÄÏõê ÌôïÏù∏
        this.checkHapticSupport();
        
        console.log('üì± TouchManager initialized with full gesture support');
    }
    
    /**
     * Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
     */
    addEventListeners() {
        // Ìå®ÏãúÎ∏å Î¶¨Ïä§ÎÑàÎ°ú ÏÑ±Îä• ÏµúÏ†ÅÌôî
        const options = { passive: false };
        
        document.addEventListener('touchstart', this.handleTouchStart.bind(this), options);
        document.addEventListener('touchmove', this.handleTouchMove.bind(this), options);
        document.addEventListener('touchend', this.handleTouchEnd.bind(this), options);
        document.addEventListener('touchcancel', this.handleTouchCancel.bind(this), options);
        
        // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ÎèÑ ÏßÄÏõê (ÌïòÏù¥Î∏åÎ¶¨Îìú ÎîîÎ∞îÏù¥Ïä§)
        document.addEventListener('mousedown', this.handleMouseDown.bind(this));
        document.addEventListener('mousemove', this.handleMouseMove.bind(this));
        document.addEventListener('mouseup', this.handleMouseUp.bind(this));
        
        // Ïª®ÌÖçÏä§Ìä∏ Î©îÎâ¥ Î∞©ÏßÄ (Î°±ÌîÑÎ†àÏä§ÏôÄ Ï∂©Îèå)
        document.addEventListener('contextmenu', (e) => {
            if (this.currentGesture === 'longPress') {
                e.preventDefault();
            }
        });
    }
    
    /**
     * ÌÑ∞Ïπò ÏãúÏûë Ï≤òÎ¶¨
     */
    handleTouchStart(event) {
        if (!this.isEnabled) return;
        
        const touch = event.touches[0];
        this.touchStartTime = Date.now();
        this.touchStartPos = { x: touch.clientX, y: touch.clientY };
        
        // Î©ÄÌã∞ÌÑ∞Ïπò Ï∂îÏ†Å
        this.updateTouches(event.touches);
        
        // ÎçîÎ∏îÌÉ≠ Í∞êÏßÄ
        this.detectDoubleTap(touch);
        
        // Î°±ÌîÑÎ†àÏä§ ÌÉÄÏù¥Î®∏ ÏãúÏûë
        this.startLongPressTimer();
        
        // Ïã±Í∏Ä/Î©ÄÌã∞ÌÑ∞ÏπòÏóê Îî∞Î•∏ Ï≤òÎ¶¨
        if (event.touches.length === 1) {
            this.handleSingleTouchStart(touch);
        } else if (event.touches.length === 2) {
            this.handleMultiTouchStart(event.touches);
        }
    }
    
    /**
     * ÌÑ∞Ïπò Ïù¥Îèô Ï≤òÎ¶¨
     */
    handleTouchMove(event) {
        if (!this.isEnabled) return;
        
        // Ïä§ÌÅ¨Î°§ Î∞©ÏßÄÍ∞Ä ÌïÑÏöîÌïú Í≤ΩÏö∞
        if (this.shouldPreventDefault(event)) {
            event.preventDefault();
        }
        
        const touch = event.touches[0];
        
        // Î°±ÌîÑÎ†àÏä§ Ï∑®ÏÜå (Ïù¥Îèô Ïãú)
        if (this.longPressTimer) {
            const distance = this.getDistance(
                this.touchStartPos,
                { x: touch.clientX, y: touch.clientY }
            );
            
            if (distance > this.config.longPress.maxMovement) {
                this.cancelLongPress();
            }
        }
        
        // ÌÑ∞Ïπò ÏàòÏóê Îî∞Î•∏ Ï≤òÎ¶¨
        if (event.touches.length === 1) {
            this.handleSingleTouchMove(touch);
        } else if (event.touches.length === 2) {
            this.handleMultiTouchMove(event.touches);
        }
        
        this.updateTouches(event.touches);
    }
    
    /**
     * ÌÑ∞Ïπò Ï¢ÖÎ£å Ï≤òÎ¶¨
     */
    handleTouchEnd(event) {
        if (!this.isEnabled) return;
        
        // Î°±ÌîÑÎ†àÏä§ Ï∑®ÏÜå
        this.cancelLongPress();
        
        // Ï†úÏä§Ï≤ò Í∞êÏßÄ Î∞è Ïã§Ìñâ
        this.detectAndExecuteGesture(event);
        
        // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        if (event.touches.length === 0) {
            this.resetGestureState();
        }
        
        this.updateTouches(event.touches);
    }
    
    /**
     * ÌÑ∞Ïπò Ï∑®ÏÜå Ï≤òÎ¶¨
     */
    handleTouchCancel(event) {
        this.cancelLongPress();
        this.resetGestureState();
        this.updateTouches(event.touches);
    }
    
    /**
     * Ïã±Í∏Ä ÌÑ∞Ïπò ÏãúÏûë Ï≤òÎ¶¨
     */
    handleSingleTouchStart(touch) {
        this.currentGesture = null;
        
        // Pan Ï†úÏä§Ï≤ò Ï§ÄÎπÑ
        this.gestureState.translation = { x: 0, y: 0 };
        this.triggerGesture('panStart', {
            x: touch.clientX,
            y: touch.clientY,
            target: touch.target
        });
    }
    
    /**
     * Ïã±Í∏Ä ÌÑ∞Ïπò Ïù¥Îèô Ï≤òÎ¶¨
     */
    handleSingleTouchMove(touch) {
        const deltaX = touch.clientX - this.touchStartPos.x;
        const deltaY = touch.clientY - this.touchStartPos.y;
        
        // Pan Ï†úÏä§Ï≤ò
        if (Math.abs(deltaX) > this.config.pan.threshold || 
            Math.abs(deltaY) > this.config.pan.threshold) {
            
            this.currentGesture = 'pan';
            this.gestureState.translation = { x: deltaX, y: deltaY };
            
            this.triggerGesture('panMove', {
                x: touch.clientX,
                y: touch.clientY,
                deltaX: deltaX,
                deltaY: deltaY,
                target: touch.target
            });
        }
    }
    
    /**
     * Î©ÄÌã∞ÌÑ∞Ïπò ÏãúÏûë Ï≤òÎ¶¨
     */
    handleMultiTouchStart(touches) {
        if (touches.length === 2) {
            this.currentGesture = 'multitouch';
            
            // Ï¥àÍ∏∞ Í±∞Î¶¨ÏôÄ Í∞ÅÎèÑ Í≥ÑÏÇ∞
            this.initialDistance = this.getDistanceBetweenTouches(touches);
            this.initialAngle = this.getAngleBetweenTouches(touches);
            this.initialCenter = this.getCenterPoint(touches);
        }
    }
    
    /**
     * Î©ÄÌã∞ÌÑ∞Ïπò Ïù¥Îèô Ï≤òÎ¶¨
     */
    handleMultiTouchMove(touches) {
        if (touches.length === 2 && this.currentGesture === 'multitouch') {
            const currentDistance = this.getDistanceBetweenTouches(touches);
            const currentAngle = this.getAngleBetweenTouches(touches);
            const currentCenter = this.getCenterPoint(touches);
            
            // ÌïÄÏπò Ï§å
            const scaleChange = currentDistance / this.initialDistance;
            if (Math.abs(scaleChange - 1) > 0.1) {
                this.gestureState.scale = Math.min(
                    Math.max(scaleChange, this.config.pinch.minScale),
                    this.config.pinch.maxScale
                );
                
                const gestureType = scaleChange > 1 ? 'pinchOut' : 'pinchIn';
                this.triggerGesture(gestureType, {
                    scale: this.gestureState.scale,
                    center: currentCenter,
                    delta: scaleChange - 1
                });
            }
            
            // ÌöåÏ†Ñ
            const rotationDelta = currentAngle - this.initialAngle;
            if (Math.abs(rotationDelta) > this.config.rotate.threshold) {
                this.gestureState.rotation = rotationDelta;
                
                this.triggerGesture('rotate', {
                    rotation: this.gestureState.rotation,
                    center: currentCenter,
                    delta: rotationDelta
                });
            }
        }
    }
    
    /**
     * ÎçîÎ∏îÌÉ≠ Í∞êÏßÄ
     */
    detectDoubleTap(touch) {
        const currentTime = Date.now();
        const timeDelta = currentTime - this.lastTouchTime;
        const distance = this.getDistance(
            this.lastTouchPos,
            { x: touch.clientX, y: touch.clientY }
        );
        
        if (timeDelta < this.config.doubleTap.maxDelay && 
            distance < this.config.doubleTap.maxDistance) {
            
            this.triggerGesture('doubleTap', {
                x: touch.clientX,
                y: touch.clientY,
                target: touch.target
            });
            
            // ÎçîÎ∏îÌÉ≠ ÌõÑ Ï¥àÍ∏∞Ìôî
            this.lastTouchTime = 0;
            this.lastTouchPos = { x: 0, y: 0 };
            
        } else {
            this.lastTouchTime = currentTime;
            this.lastTouchPos = { x: touch.clientX, y: touch.clientY };
        }
    }
    
    /**
     * Ï†úÏä§Ï≤ò Í∞êÏßÄ Î∞è Ïã§Ìñâ
     */
    detectAndExecuteGesture(event) {
        if (this.currentGesture === 'pan') {
            this.triggerGesture('panEnd', {
                x: this.lastTouchPos.x,
                y: this.lastTouchPos.y,
                deltaX: this.gestureState.translation.x,
                deltaY: this.gestureState.translation.y
            });
            return;
        }
        
        // Ïä§ÏôÄÏù¥ÌîÑ Í∞êÏßÄ
        const swipeGesture = this.detectSwipe();
        if (swipeGesture) {
            this.triggerGesture(swipeGesture.type, swipeGesture.data);
            return;
        }
        
        // Í∞ÑÎã®Ìïú ÌÉ≠
        if (!this.currentGesture) {
            const touch = event.changedTouches[0];
            this.triggerGesture('tap', {
                x: touch.clientX,
                y: touch.clientY,
                target: touch.target
            });
        }
    }
    
    /**
     * Ïä§ÏôÄÏù¥ÌîÑ Í∞êÏßÄ
     */
    detectSwipe() {
        const timeDelta = Date.now() - this.touchStartTime;
        const touch = event.changedTouches[0];
        const deltaX = touch.clientX - this.touchStartPos.x;
        const deltaY = touch.clientY - this.touchStartPos.y;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // Ïä§ÏôÄÏù¥ÌîÑ Ï°∞Í±¥ ÌôïÏù∏
        if (timeDelta > this.config.swipe.maxTime || 
            distance < this.config.swipe.minDistance) {
            return null;
        }
        
        // Î∞©Ìñ• Í≤∞Ï†ï
        const absX = Math.abs(deltaX);
        const absY = Math.abs(deltaY);
        
        let direction;
        let deviation;
        
        if (absX > absY) {
            // ÏàòÌèâ Ïä§ÏôÄÏù¥ÌîÑ
            direction = deltaX > 0 ? 'swipeRight' : 'swipeLeft';
            deviation = absY;
        } else {
            // ÏàòÏßÅ Ïä§ÏôÄÏù¥ÌîÑ
            direction = deltaY > 0 ? 'swipeDown' : 'swipeUp';
            deviation = absX;
        }
        
        // Ìé∏Ï∞® ÌôïÏù∏
        if (deviation > this.config.swipe.maxDeviation) {
            return null;
        }
        
        return {
            type: direction,
            data: {
                distance: distance,
                deltaX: deltaX,
                deltaY: deltaY,
                duration: timeDelta,
                startX: this.touchStartPos.x,
                startY: this.touchStartPos.y,
                endX: touch.clientX,
                endY: touch.clientY
            }
        };
    }
    
    /**
     * Î°±ÌîÑÎ†àÏä§ ÌÉÄÏù¥Î®∏ ÏãúÏûë
     */
    startLongPressTimer() {
        this.longPressTimer = setTimeout(() => {
            this.currentGesture = 'longPress';
            
            this.triggerGesture('longPress', {
                x: this.touchStartPos.x,
                y: this.touchStartPos.y,
                duration: this.config.longPress.duration
            });
            
            // ÌñÖÌã± ÌîºÎìúÎ∞±
            this.triggerHapticFeedback('medium');
            
        }, this.config.longPress.duration);
    }
    
    /**
     * Î°±ÌîÑÎ†àÏä§ Ï∑®ÏÜå
     */
    cancelLongPress() {
        if (this.longPressTimer) {
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
    }
    
    /**
     * Ï†úÏä§Ï≤ò ÏΩúÎ∞± Îì±Î°ù
     */
    on(gestureType, callback) {
        if (!this.gestureTypes.includes(gestureType)) {
            console.warn(`Unknown gesture type: ${gestureType}`);
            return;
        }
        
        if (!this.gestureCallbacks.has(gestureType)) {
            this.gestureCallbacks.set(gestureType, new Set());
        }
        
        this.gestureCallbacks.get(gestureType).add(callback);
    }
    
    /**
     * Ï†úÏä§Ï≤ò ÏΩúÎ∞± Ï†úÍ±∞
     */
    off(gestureType, callback) {
        if (this.gestureCallbacks.has(gestureType)) {
            this.gestureCallbacks.get(gestureType).delete(callback);
        }
    }
    
    /**
     * Ï†úÏä§Ï≤ò Ìä∏Î¶¨Í±∞
     */
    triggerGesture(gestureType, data = {}) {
        if (this.gestureCallbacks.has(gestureType)) {
            this.gestureCallbacks.get(gestureType).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Gesture callback error (${gestureType}):`, error);
                }
            });
        }
    }
    
    /**
     * ÌäπÏ†ï ÏöîÏÜåÏóê Ï†úÏä§Ï≤ò Î∞îÏù∏Îî©
     */
    bindElement(element, gestureType, callback, options = {}) {
        const wrappedCallback = (data) => {
            if (data.target === element || element.contains(data.target)) {
                callback(data);
            }
        };
        
        this.on(gestureType, wrappedCallback);
        
        // ÏöîÏÜåÏóê Ï†ïÎ≥¥ Ï†ÄÏû• (ÎÇòÏ§ëÏóê unbind Ìï† Ïàò ÏûàÎèÑÎ°ù)
        if (!element._touchGestures) {
            element._touchGestures = new Map();
        }
        element._touchGestures.set(gestureType, wrappedCallback);
        
        return wrappedCallback;
    }
    
    /**
     * ÏöîÏÜåÏùò Ï†úÏä§Ï≤ò Î∞îÏù∏Îî© Ìï¥Ï†ú
     */
    unbindElement(element, gestureType) {
        if (element._touchGestures && element._touchGestures.has(gestureType)) {
            const callback = element._touchGestures.get(gestureType);
            this.off(gestureType, callback);
            element._touchGestures.delete(gestureType);
        }
    }
    
    /**
     * ÌñÖÌã± ÌîºÎìúÎ∞± Ìä∏Î¶¨Í±∞
     */
    triggerHapticFeedback(intensity = 'light') {
        if (!this.hapticSupported) return;
        
        try {
            if (navigator.vibrate) {
                const patterns = {
                    light: [10],
                    medium: [20],
                    heavy: [30],
                    double: [10, 50, 20],
                    success: [10, 50, 10, 50, 20],
                    error: [50, 50, 50]
                };
                
                navigator.vibrate(patterns[intensity] || patterns.light);
            }
        } catch (error) {
            console.warn('Haptic feedback failed:', error);
        }
    }
    
    /**
     * ÎîîÎ∞îÏù¥Ïä§ Í∞êÏßÄ
     */
    detectDevice() {
        this.deviceInfo = {
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            isTablet: /iPad|Android(?!.*Mobile)/i.test(navigator.userAgent),
            isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
            isAndroid: /Android/i.test(navigator.userAgent),
            hasTouch: 'ontouchstart' in window || navigator.maxTouchPoints > 0
        };
        
        // ÎîîÎ∞îÏù¥Ïä§Î≥Ñ ÏÑ§Ï†ï Ï°∞Ï†ï
        if (this.deviceInfo.isIOS) {
            this.config.doubleTap.maxDelay = 250; // iOSÎäî Îçî Îπ†Î¶Ñ
        }
        
        console.log('üì± Device detected:', this.deviceInfo);
    }
    
    /**
     * ÌñÖÌã± ÌîºÎìúÎ∞± ÏßÄÏõê ÌôïÏù∏
     */
    checkHapticSupport() {
        this.hapticSupported = 'vibrate' in navigator;
        console.log(`üéõÔ∏è Haptic feedback: ${this.hapticSupported ? 'Supported' : 'Not supported'}`);
    }
    
    /**
     * Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄ Ïó¨Î∂Ä Í≤∞Ï†ï
     */
    shouldPreventDefault(event) {
        // Ïä§ÌÅ¨Î°§ Î∞©ÏßÄÍ∞Ä ÌïÑÏöîÌïú ÏÉÅÌô©Îì§
        return this.currentGesture === 'pan' || 
               this.currentGesture === 'multitouch' ||
               event.touches.length > 1;
    }
    
    /**
     * ÌÑ∞Ïπò Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateTouches(touches) {
        this.touches.clear();
        
        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            this.touches.set(touch.identifier, {
                x: touch.clientX,
                y: touch.clientY,
                target: touch.target
            });
        }
    }
    
    /**
     * Îëê Ï†ê ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨ Í≥ÑÏÇ∞
     */
    getDistance(point1, point2) {
        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Îëê ÌÑ∞Ïπò Ìè¨Ïù∏Ìä∏ ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨
     */
    getDistanceBetweenTouches(touches) {
        return this.getDistance(
            { x: touches[0].clientX, y: touches[0].clientY },
            { x: touches[1].clientX, y: touches[1].clientY }
        );
    }
    
    /**
     * Îëê ÌÑ∞Ïπò Ìè¨Ïù∏Ìä∏ ÏÇ¨Ïù¥Ïùò Í∞ÅÎèÑ
     */
    getAngleBetweenTouches(touches) {
        const dx = touches[1].clientX - touches[0].clientX;
        const dy = touches[1].clientY - touches[0].clientY;
        return Math.atan2(dy, dx) * 180 / Math.PI;
    }
    
    /**
     * Îëê ÌÑ∞Ïπò Ìè¨Ïù∏Ìä∏Ïùò Ï§ëÏã¨Ï†ê
     */
    getCenterPoint(touches) {
        return {
            x: (touches[0].clientX + touches[1].clientX) / 2,
            y: (touches[0].clientY + touches[1].clientY) / 2
        };
    }
    
    /**
     * Ï†úÏä§Ï≤ò ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
     */
    resetGestureState() {
        this.currentGesture = null;
        this.gestureState = {
            scale: 1,
            rotation: 0,
            translation: { x: 0, y: 0 }
        };
        this.initialDistance = null;
        this.initialAngle = null;
        this.initialCenter = null;
    }
    
    /**
     * ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ (ÌïòÏù¥Î∏åÎ¶¨Îìú ÎîîÎ∞îÏù¥Ïä§ ÏßÄÏõê)
     */
    handleMouseDown(event) {
        if (this.deviceInfo.hasTouch) return; // ÌÑ∞Ïπò ÎîîÎ∞îÏù¥Ïä§ÏóêÏÑúÎäî Î¨¥Ïãú
        
        this.touchStartTime = Date.now();
        this.touchStartPos = { x: event.clientX, y: event.clientY };
        this.startLongPressTimer();
    }
    
    handleMouseMove(event) {
        if (this.deviceInfo.hasTouch) return;
        
        if (this.longPressTimer) {
            const distance = this.getDistance(
                this.touchStartPos,
                { x: event.clientX, y: event.clientY }
            );
            
            if (distance > this.config.longPress.maxMovement) {
                this.cancelLongPress();
            }
        }
    }
    
    handleMouseUp(event) {
        if (this.deviceInfo.hasTouch) return;
        
        this.cancelLongPress();
        
        // Í∞ÑÎã®Ìïú ÌÅ¥Î¶≠ Ï≤òÎ¶¨
        this.triggerGesture('tap', {
            x: event.clientX,
            y: event.clientY,
            target: event.target
        });
    }
    
    /**
     * Ï†úÏä§Ï≤ò ÌÜµÍ≥Ñ
     */
    getGestureStats() {
        const stats = {};
        
        this.gestureTypes.forEach(type => {
            stats[type] = this.gestureCallbacks.has(type) ? 
                this.gestureCallbacks.get(type).size : 0;
        });
        
        return stats;
    }
    
    /**
     * ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        console.log('üì± TouchManager configuration updated');
    }
    
    /**
     * ÌÑ∞Ïπò Îß§ÎãàÏ†Ä ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî
     */
    setEnabled(enabled) {
        this.isEnabled = enabled;
        if (!enabled) {
            this.cancelLongPress();
            this.resetGestureState();
        }
        console.log(`üì± TouchManager ${enabled ? 'enabled' : 'disabled'}`);
    }
    
    /**
     * ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ Ï∂úÎ†•
     */
    debug() {
        console.group('üì± TouchManager Debug Info');
        console.log('Enabled:', this.isEnabled);
        console.log('Device Info:', this.deviceInfo);
        console.log('Current Gesture:', this.currentGesture);
        console.log('Gesture State:', this.gestureState);
        console.log('Gesture Stats:', this.getGestureStats());
        console.log('Configuration:', this.config);
        console.groupEnd();
    }
    
    /**
     * Touch Manager ÌååÍ¥¥ (cleanup)
     */
    destroy() {
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
        document.removeEventListener('touchstart', this.handleTouchStart);
        document.removeEventListener('touchmove', this.handleTouchMove);
        document.removeEventListener('touchend', this.handleTouchEnd);
        document.removeEventListener('touchcancel', this.handleTouchCancel);
        document.removeEventListener('mousedown', this.handleMouseDown);
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('mouseup', this.handleMouseUp);
        
        // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
        this.cancelLongPress();
        if (this.doubleTapTimer) {
            clearTimeout(this.doubleTapTimer);
        }
        
        // ÏΩúÎ∞± Ï†ïÎ¶¨
        this.gestureCallbacks.clear();
        this.touches.clear();
    }
}

// Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
window.touchManager = new TouchManager();

console.log('üì± TouchManager.js loaded - Full gesture support + haptic feedback');

export default TouchManager;